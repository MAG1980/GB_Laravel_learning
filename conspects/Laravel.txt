При внесении изменений в файл .env под Windows к нему применяется кодировка DOS и возникают ошибки
./.env: line 6: $'\r': command not found
Преобразовать кодировку обратно можно с помощью команды:
$ dos2unix .env .env
dos2unix: converting file .env to Unix format...

Возникала ошибка
SQLSTATE[HY000] [1044] Access denied for user 'sail'@'%' to database 'example_app' (SQL: select * from information_schema.tables where table_schema = example_app and table_name = migrations and table_type = 'BASE TABLE')

Решил с помощью этой инструкции:
https://gist.github.com/jjsquady/e12ce89c9029d520ce08f60a9ff8f304
Выполнил команды:
docker-compose exec mysql bash

bash-4.4# mysql -u root -p
Enter password:
password (символы не отображаются)

mysql> mysql -u root -p

mysql> GRANT ALL PRIVILEGES ON *.* TO 'sail'@'%';
Query OK, 0 rows affected (0.01 sec)

mysql> FLUSH PRIVILEGES;
Query OK, 0 rows affected (0.01 sec)

mysql> EXIT;


Советы по работе с Docker:

если идти на 127.0.0.1, то надо указывать внешний  порт проброса.
если идти на  172.17.88.101  то надо идти на внутренний.

то есть проброс

ports : 33060:3306
первый внешний, второй внутренний.

А  еще, есть команда docker inspect,
которая покажет всю инфу по контейнеру.



Чтобы удалить пакет из проекта нужно использовать откат в Composer:
удалить строчку пакета в json и папку vendor и сделать install

Чтобы подключиться к удалённому репозиторию, пришлось создать ветку dev.
$ git pull выдавала ошибку.
--------------------------------------------------------------
$ git pull
У текущей ветки нет информации об отслеживании.
Пожалуйста, укажите с какой веткой вы хотите слить изменения.
Для дополнительной информации, смотрите git-pull(1).

    git pull <внешний-репозиторий> <ветка>

Если вы хотите указать информацию о отслеживаемой ветке, выполните:

    git branch --set-upstream-to=origin/<ветка> dev
----------------------------------------------------------
Сработала команда, где  origin/dev — название «удалённой» ветки,
а dev — название локальной.

$ git branch --set-upstream-to=origin/dev dev
Ветка «dev» отслеживает внешнюю ветку «dev» из «origin».
$ git pull
fatal: отказ слияния несвязанных историй изменений
$ git fetch
$ git reset --hard origin/dev
Указатель HEAD сейчас на коммите f87ae1f Начало практики к уроку №2. Создан HomeController.
alexey@pc34:~/PhpstormProjects/Laravel-learning$ git pull

Проблема подключения к внешнему репозиторию решена.


wsl - запустить Linux в Windows

Чтобы создать новое приложение Laravel в каталоге с именем «example-app», вы можете запустить следующую команду в своем терминале:
curl -s https://laravel.build/example-app | bash - установка Laravel Sail

./vendor/bin/sail up - запустить Sail

Установка Laravel Sail

Linux:

    Follow the official install instructions for Docker CE/EE for your distribution. If you are using Docker Compose, follow the Docker Compose directions as well.

 !!!   Add your user to the docker group by using a terminal to run: sudo usermod -aG docker $USER      !!!

    Sign out and back in again so your changes take effect.


Чтобы подключиться к виртуальной Linux из PHPStorm нужно в его терминале ввести команду wsl.

alias sail="bash ./vendor/bin/sail" - создание псевдонима для команды запуска проекта (нужно создавать и запускать из папки проекта).

С использованием псевдонима:
sail up -d - с отсоединением консоли

Урок 2. Роутинг. Использование контроллеров

В старых версиях PHPStorm может потребоватья настроить IDEHelper (ServiceProvider).
Сейчас IDE берёт список методов из PHPDoc класса.

Маршруты хранятся в папке routes.
Маршруты SSR хранятся в файле web.php
Маршруты SPA хранятся в файле api.php

Маршруты задаются с помощью статических методов класса Route, который наследуется от фасада.
Laravel при первом обращении к классу Router создаёт в контейнере его экземпляр.
Реализация паттерна Facade позволяет скрыть сложную релализацию за простым фасадом.

При создании маршрута в первую очередь указывается его HTTP-метод.
Route::get (post), который первым параметром принимает адрес, а вторым - коллбек-функцию-обработчик,
которая возвращает нужный хэлпек view или сразу данные (HTML?).

Route::match(['post', 'get']) - статический метод класса Route,
позволяющий обрабатывать все HTTP-методы, указанные в массиве.

Представления - view хранятся в ~/resources/views


Route::get('/info', function () {
    return view('info');
});
эта запись аналогична следующей:
Route::view('/info', 'info');
});


Вместо view можно передать HTML-разметку:
Route::view('/test', 'test');

Передать данные в представление ('news' - переменная, $news - значение)
        view('news.news')->with ('news', $news);

Первый параметр - alias,
второй параметр - название шаблона,
третьим параметром можно передать ассоциативный массив со значениями переменных шаблона.
В маршрут можно передать значения переменных в виде массива, который передаётся третим параметром:
Route::view('/', 'index', [
	'name' => 'Admin'
]);


В этом варианте не используются модель и контроллер.
Это можно делать, если передача данных в шаблон не требуется.

Более правильный вариант - с использованием контроллера:
Route::get('/', [HomeController::class, index]);
HomeController - класс, который наследуется от Controller и содержит метод-обработчик (index).

slug — осмысленное строковое значение. Как правило с символами подчеркивания (или точки) вместо пробелов

Пример маршрута с параметром:
Route::get('/{slug}', [HomeController::class, index]);

значение slug будет доступно в параметре ($slug) метода index контроллера HomeController,
при этом важно не забыть её принять: public function index($slug)

Route::get('/{category}/buy/{slug}', [HomeController::class, index]);
Если параметров маршрута несколько, то их нужно перечислить через запятую: public function index($category, $slug)

StyleGuide:
Важно -
при создании маршрутов, псевдонимов маршрутов, методов-обработчиков маршрутов в контроллерах, представлений
следует придерживаться одинаковых именований:
Route::get('/create', [AdminNewsController::class, 'create'])->name('create');



Чтобы создать HomeController, используя средства Laravel, нужно ввести команду
$ sail artisan make:controller HomeController
Эта команда будет вызывать ошибку, если в приложении уже есть строка,
в которой происходит обращение к несуществующему контроллеру (её нужно предварительно закомментировать),
т.к. перед выполнением команды artisan выполняет код приложения.


sail artisan help make:controller

Artisan - интерфейс командной строки, который в Laravel используется для ввода команд,
ускоряющих разработку приложения (для автоматической генерации кода).
Дли использования artisan нужно выполнить команду: $ php artisan
При использовании Laravel Sail: $sail artisan

Чтобы получить подробную информацию по команде, следует указать после artisan слово help и имя нужной команды.
Например:
$ sail artisan help make:controller




Для перенаправления на другую страницу используется метод redirect:
Route::redirect('маршрут', 'маршрут, на который осуществляется перенаправление', код ответа сервера);
Route::redirect('redir', '/', 301);

Кастомную страницу 404 можно сделать с помощью метода fallback:
Route::fallback(function (){
	return view('beauty_404');
});

!!! Маршрут страницы 404 должен располагаться в самом низу списка маршрутов.

Если из БД вместо данных получен NULL, то в контроллере следует сделать редирект на "404" .
if(is_null($data)){
	return redirect()->action([HomeController::class, 'index']);
}

$ php artisan route:list - выводит список зарегистрированных маршрутов
$ php artisan route:list --except-path=api,_ignition,sanctum - вывести только пользовательские маршруты

$ php artisan route:cache - кешировать маршруты.
После этого Laravel берёт информацию о маршрутах не из папки routes, а из кеша.
Кеширование маршрутов обязательно нужно делать на рабочем сервере (в ProductionMode), т.к. сборка маршрутов занимает много времени.


Очистка кеша (кэш) cache Laravel:
$ sail artisan cache:clear
$ sail artisan config:clear (.env)
$ sail artisan route:clear
$ sail artisan view:clear


!!! При использовании Laravel Sail вместо php нужно писать sail
sail artisan route:list

Если не использовать сырую разметку (вывод через {!! .... !!} ) и использовать валидаторы (либо в контроллерах, либо FormRequest, то ларка вполне безопасна)))
при ошибке валидации автоматом же в old значения попадут и будет редирект обратно в форму

Помещать функционал контроллера в роутер - плохая идея.

В Laravel контроллеры хранятся в папке ~/api/Http/Controllers, в том числе базовый класс Controller.

Хэлпер dump используется для отладки.
Он позволяет вывести информацию о значении переменной без остановки вывода.

Хэлпер dd выводит информацию о значении переменной с остановкой вывода.

Дополнительное ДЗ от преподавателя:
1:40 -

Контроллеры принято разносить по разным папкам.
Например, контролеры для путей, доступны только админу будем хранить в папке Admin.

Route::get('/admin', [
	'uses' => 'Admin\IndexController@index' — после @ указано название метода
]);


Чтобы устранить ошибки после подключения репозитория к Ubuntu пришлось стать владельцем папки проекта с помощью команды:
sudo chmod o+w ./Laravel-learning/ -R



$ sail artisan tinker — позволяет вывести значение какого-либо хэлпера:

root@pc34:/home/alexey/PhpstormProjects/Laravel-learning# sail artisan tinker
Psy Shell v0.11.8 (PHP 8.1.11 — cli) by Justin Hileman
>>> view('index')
=> Illuminate\View\View {#3673}

>>> route('home')
Symfony\Component\Routing\Exception\RouteNotFoundException with message 'Route [home] not defined.'
>>> route('404')
=> "http://localhost/404"

Иногда вам может понадобиться запустить сеанс Bash в контейнере вашего приложения.
Вы можете использовать эту shell команду для подключения к контейнеру вашего приложения,
что позволит вам проверять его файлы и установленные службы, а также выполнять произвольные команды оболочки внутри контейнера:

sail shell
 
sail root-shell

Чтобы передать в шаблон псевдоним маршрута необходимо использовать хэлпер route()
route('имя маршрута', 'параметр запроса (необяз.)')

<a href="<?=route('news.one', $item['id']) ?>"><?= $item['title'] ?></a><br>


Чтобы выделить текущий пункт меню можно использовать хэлпер named('имя маршрута')
/**
 * Handle an incoming request.
 *
 * @param  \Illuminate\Http\Request  $request
 * @param  \Closure  $next
 * @return mixed
 */
public function handle($request, Closure $next)
{
    if ($request->route()->named('profile')) {
        //
    }
 
    return $next($request);
}
или

Route::is('имя маршрута'):boolean


Для группировки маршрутов по имени используется хэлпер Route::name('имя маршрута'), а для группировки по префиксу Route::prefix('префикс')

StyleGuide: Route::name('имя маршрута') - имя маршрута должно быть таким же, как имя шаблона или имя метода контроллера.

Для группировки маршрутов используется хэлпер group(callback):

Route::name('admin.')
    ->prefix('admin')
    ->group(function () {
        Route::get('/', [IndexController::class, 'index'])->name('index');
        Route::get('/test1', [IndexController::class, 'test1'])->name('test1');
        Route::get('/test2', [IndexController::class, 'test2'])->name('test2');

    });

Маршруты можно группировать и по namespace: Route::namespace('namespace')

Для перенаправления на нужный маршрут в случае отстутствия нужной страницы (данных)
использутеся хэлпер ->missing(function(
	{
		return view('product.not_found');
	}));


Для SEO важно в маршрутах использовать слова:
/news/category/1 	- плохо
/news/category/sport	- хорошо

Str::slug - Метод генерирует дружественный URL-адрес "slug" из заданной строки:
use Illuminate\Support\Str;
$slug = Str::slug('Laravel 5 Framework', '-');


Советы к ДЗ:
Добавить в массивы новостей и категорий ключи ID, которые совпадают с id новости или категории, чтобы не искать новость перебором.

https://www.youtube.com/watch?v=8X77WSGg29c


Laravel Livewire используется для создания динамических интерфейсов без использования JS, Vue или React.
Laravel Livewire - спорная ("игрушечная" технология),
т.к., например, во время ввода данных в input, на сервер посылается огромное количество запросов,
что приводит к перегрузке сервера.

Правильнее будет использование JavaScript-фреймворка Alpine.js

Шаблонизатор даёт скорость, гибкость и безопасность.

Шаблонизатор Blade позволяет писать PHP-код внутри {{ }}, т.е. даже вызывать PHP-функции,
поэтому внутри {{ $varable }} перед именем переменной нужно ставить знак $.
JavaScript-код, содержащийся в переменной, выводимой в шаблон, будет экранирован.
Чтобы отключить экранирование Javascript нужно использовать {!! $variable !!}

Поскольку многие фреймворки JavaScript также используют «фигурные» скобки для обозначения того,
что данное выражение должно отображаться в браузере, вы можете использовать @символ,
чтобы сообщить механизму рендеринга Blade, что выражение должно оставаться нетронутым.
Например:

<h1>Laravel</h1>
Hello, @{{ name }}.

В этом примере @символ будет удален Blade;
тем не менее, {{ name }}выражение останется нетронутым движком Blade,
что позволит вам отображать его с помощью вашей инфраструктуры JavaScript.

Этот @символ также может использоваться для экранирования директив Blade:

{{-- Blade template --}}
@@if()
<!-- HTML output -->
@if()

Если вы отображаете переменные JavaScript в большей части своего шаблона,
вы можете обернуть HTML в @verbatimдирективу,
чтобы вам не нужно было префикс каждого оператора эха Blade @символом:

@verbatim
    <div class="container">
        Hello, {{ name }}.
    </div>
@endverbatim

Экранирование рендеринга атрибутов
Поскольку некоторые фреймворки JavaScript, такие как Alpine.js,
также используют атрибуты с префиксом двоеточия, вы можете использовать префикс с двойным двоеточием ( ::),
чтобы сообщить Blade, что атрибут не является выражением PHP. Например, для следующего компонента:

<x-button ::class="{ danger: isDeleting }">
    Submit
</x-button>

Следующий HTML будет отображаться Blade:

<button :class="{ danger: isDeleting }">
    Submit
</button>



Макеты с использованием наследования шаблонов

Директива @section, как следует из названия, определяет раздел содержимого,
а @yield директива используется для отображения содержимого данного раздела.

<!-- resources/views/layouts/app.blade.php -->

<html>
    <head>
        <title>App Name - @yield('title')</title>
    </head>
    <body>
        @section('sidebar')
            This is the master sidebar.
        @show
        <div class="container">
            @yield('content')
        </div>
    </body>
</html>

Расширение макета
При определении дочернего представления используйте @extends директиву Blade, чтобы указать, какой макет дочернее представление должно «наследовать».
Представления, расширяющие макет Blade, могут вставлять содержимое в разделы макета с помощью @section директив.
Помните, как видно из приведенного выше примера, содержимое этих разделов будет отображаться в макете с помощью @yield:

<!-- resources/views/child.blade.php -->

@extends('layouts.app')
@section('title', 'Page Title')
@section('sidebar')
    @parent
     <p>This is appended to the master sidebar.</p>
@endsection
@section('content')
    <p>This is my body content.</p>
@endsection

В этом примере sidebarраздел использует @parentдирективу для добавления (а не перезаписи) контента на боковую панель макета.
Директива @parentбудет заменена содержимым макета при отображении представления.


Для подключения Vue, React или Bootstrap к Laravel можно использовать пакет Laravel/UI
https://packagist.org/packages/laravel/ui#v4.0.2
с помощью команды:
composer require laravel/ui

Для установки пакета Laravel/UI в контейнер Docker (Laravel Sail)
нужно сначала запустить конетейнер командой sail up,
а затем выполнить команду

sail composer require laravel/ui

Далее следовать инструкции на сайте https://packagist.org/packages/laravel/ui#v4.0.2

Например, чтобы подключить Vue с Bootstrap и автоматическим созданием шаблонов форм авторизации, нужно выполнить команду:

sail artisan ui vue --auth

При этом автоматически будут созданы:

resources/views/layouts/app.blade.php
resources/js/components/ExampleComponent.vue
resources/js/app.js
resources/js/app.bootstrap.js
и т.п.


Вообще, чтобы выполнять любые команды внутри контейнера Docker,
в том числе и npm,
нужно обязательно вводить префикс ./vendor/bin/sail (или использовать алиас sail), например:

sail npm run dev - чтобы запустить live-server для разработки UI

sail npm run build - сборка Frontend (css и JS) для production



Для подключения ресурсов (стилей и JS) в шаблонах нужно использовать директиву @vite (образец - в app.blade.php, который сгенерировал laravel/ui):

 @vite(['resources/sass/app.scss', 'resources/js/app.js'])

где перечислены точки входа стилей и JS. Остальные стили должны подключаться в точке входа через директиву @import.
(В точке входа (файле resources/sass/app.scss) подключить свои стили с помощью директивы @import 'my-app.scss';)

При разработке SPA точку входа CSS лучше не использовать.
Вместо этого стили нужно импортировать в resources/js/app.js файле вашего приложения:

import './bootstrap';
import '../css/app.css';


Необходимо сообщить Vite о ваших ресурсах, импортировав статические ресурсы в точку входа приложения.
Например, если вы хотите обрабатывать и версионировать все изображения,
хранящиеся в , resources/images и все шрифты,
хранящиеся в resources/fonts,
вы должны добавить следующее в resources/js/app.jsточку входа вашего приложения:

import.meta.glob([
  '../images/**',
  '../fonts/**',
]);

Эти активы теперь будут обрабатываться Vite при запуске npm run build. Затем вы можете ссылаться на эти активы в шаблонах Blade, используя Vite::assetметод, который вернет версионный URL-адрес для данного актива:

<img src="{{ Vite::asset('resources/images/logo.png') }}">


Рендеринг на стороне сервера (SSR)
Плагин Laravel Vite упрощает настройку рендеринга на стороне сервера с помощью Vite. Для начала создайте точку входа SSR resources/js/ssr.jsи укажите точку входа, передав параметр конфигурации плагину Laravel:

import { defineConfig } from 'vite';
import laravel from 'laravel-vite-plugin';

export default defineConfig({
    plugins: [
        laravel({
            input: 'resources/js/app.js',
            ssr: 'resources/js/ssr.js',
        }),
    ],
});

Чтобы убедиться, что вы не забыли пересобрать точку входа SSR, мы рекомендуем дополнить скрипт «build» в вашем
приложении, package.json чтобы создать сборку SSR:

"scripts": {
     "dev": "vite",
     "build": "vite build"
     "build": "vite build && vite build --ssr"
}

Затем, чтобы построить и запустить сервер SSR, вы можете выполнить следующие команды:

npm run build
node bootstrap/ssr/ssr.mjs


 @csrf - хэлпер, позволяющий подтвердить Laravel, что форма была отправлена из доверенного приложения.
Для этого следует добавить директиву @csrf в шаблон внутри формы.
При этом в HTML на стороне клиента при добавлении хелпера @csrf на его месте добавляется скрытый input,
в котором и передается тот самый токен.

Полезные методы класса RequestФ:
● method — возвращает строку, в которой содержится имя метода запроса.
● isMethod — возвращает bool-тип. Принимает строковый параметр и проверяет, соответствует
ли имя метода запроса переданной строке.
● has — принимает строковый параметр и проверяет, был ли передан данный элемент в форме.
Возвращает bool-тип.
● all — возвращает массив с данными, переданными в форме.
● input — принимает два параметра: имя элемента, который мы ожидаем из формы, и данные,
которые нужно заполнить, если этот элемент пуст или отсутствует. Второй параметр
необязателен.
● only — возвращает массив, состоящий только из тех элементов формы, которые переданы в
качестве параметров данного метода.
● except — возвращает массив, состоящий только из тех элементов формы, которые не
переданы в качестве параметров данного метода.
● path — возвращает url-путь без имени домена.
● url — возвращает url без get-параметров.
● fullUrl — возвращает полный url.
● query() — если вызывается метод без параметров, то возвращает массив всех параметров,
переданных методом get. Если передан параметр в качестве строки, то возвращает из get
значение данного параметра.

  Хэлпер old() используется в случае неудачной валидации

● flash() - сохраняет текущие данные в сессию (в "одноразовой" сессии).
● old() - позволяет прочитать данные из сессии.

<input type="text" value="{{ old('title') }}"> - позволит заполнить форму сохранёнными в сессии данными.



Хэлпер request()->routeIs('home') возвращает true, если адрес теущей страницы совпадает с названием маршрута ('home').
В сочетании с тернарным оператором удобно присваивать класс active текущему пункту меню:
<a class="nav-link {{ request()->routeIs('login') ? 'active' : '' }}" href="{{ route('login') }}">Login</a>

По умолчанию input type='checkbox' при установленной галочке возвращает 'on'.
Чтобы заменить значение, возвращаемое input type='checkbox', нужно присвоить ему атрибут value='нужное значение'.
Если checkbox не будет установлен, то значение для соответствующего name формы на сервер не придёт.

И показывать форму и обрабатывать данные, полученные через неё можно в одном методе.
Для этого маршрут нужно обработать с помощью метода Route::match(...);
  Route::match(['get', 'push'],'/create', [AdminNewsController::class, 'create'])->name('create');


Браузер определяет, что нужно делать с полученными из формы данными по полученным заголовкам.
Изображения принято хранить в папке Storage.
В образовательных целях временно будем хранить изображения в папке public.

Получить доступ к экземпляру класса Response можно с помощью хэлпера response().

С помощью метода download() класса Response можно скачать данные (при этом нужные загловки будут сформированы автоматически:
response()→download('fileName.ext');

Чтобы скачать данные формы в формате JSON, нужно использовать метод json():
response()→json()

public function test2(News $news)
{
	return response()→json($news→getNews()); - без указания заголовков
}

Метод контролера (как вариант) должен вернуть полученные данные.

    public function test2(News $news){							//инъекция зависимости от класса News
        return response()->json($news->getNews())					//используем метод getNews() класса News для получения всех новостей и преобразуем ответ в формат JSON
            ->header('Content-Disposition', 'attachment; filename = "news.txt"')	//указываем, что ответ нужно сохранить в виде файла
            ->setEncodingOptions(JSON_UNESCAPED_UNICODE | JSON_PRETTY_PRINT);		//преобразуем символы UNICODE (\u041D)  в кириллицу
    }

За пределами Laravel преобразовать кириллицу в UNICODE можно, например, так:
json_encode($str, JSON_UNESCAPED_UNICODE);

В /config/filesystems.php содержатся настройки, которые позволяют Laravel работать с файлами.
По умолчанию Laravel хранит скомпилилованные файлы приложения в папке /storage/app,
при этом данные, хранящиеся в папке /storage/app/public могут быть доступны извне сервера.

Для работы с файлами в контроллер необходимо подключить фасад Storage, который имеет
метод Storage::disk('название одного из дисков, указанных в файле /config/filesystems.php').
К данным, возвращаемым методом disk() можно применять методы
Storage::disk('disk_name')->get('filename.ext');	//чтение из файла
и
Storage::disk('disk_name')->put('filename.ext');	//запись в файл

В ДЗ потребуется news.json:
Storage::disk('local')->put('news.json', json_encode($news->getNews(), JSON_UNESCAPED_UNICODE | JSON_PRETTY_PRINT));
В результате будет создан файл в каталоге /storage/public.

В методе News::getNews() можно использовать
//json_decode('file_name', true); - по умолчанию возвращает объект, с опцией true возвращает массив

Для скачивания данных в формате xls или pdf можно использовать библиотеку Laravel excel

При работе в Laravel не следует использовать функции PHP file_get_contens() и file_put_contents(), т.к. это менее безопасно.

Пояснение ДЗ в видео - 1:29:30, 1:40:42, 1:47:30
ДЗ - создать страницу с формой "Скачать".
ДЗ - найти, как создать JSON-файл с помощью команды artisan

Настройка тестирования в Docker: 1:30:20
Для тестирования Laravel Sail в PHPStorm нажатием стрелки нужно установить и активировать плагины PHP и PHPDocker.
После этого в настройках PHP IDE нужно добавить новый CLI интерпретатор предварительно запустив контейнер Sail (при этом
 нужно в настройках сервера нажать кнопку "New").

Самый простой способ запустить тесты - использовать команду:

$php artisan test или $sail artisan test

Тестирование в Laravel:
https://www.youtube.com/watch?v=nef9Rozfp_U


Урок 5. Работа с базой данных. Запросы. Миграции

Метод для сохранения данных в файл:
public function save(News $news)
{
    \Illuminate\Support\Facades\Storage::disk('local')->put(
        'news.json',
        json_encode($news->getNews(),
        JSON_BIGINT_AS_STRING | JSON_PRETTY_PRINT));
}

Для создания пользовательской сервисной команды для artisan служит команда make:command,
которая создаёт файл ~app/Console/Commands/savejson.php:

sail artisan make:command savejson      //savejson - название команды
 INFO  Console command [app/Console/Commands/savejson.php] created successfully.

Файл ~app/Console/Commands/savejson.php содержит класс, расширяющий App\Console\Commands.
В нём нужно описать сигнатуру команды (protected $signature = 'save:json';),
а также переопределить метод обработчик handle();

При этом новая команда использует консольную точку входа в приложение.




php artisan help make:migration - вывести список доступных команд

Создадим новую таблицу для сохранения новостей. Для этого введем команду:
sail artisan make:migration create_news_table --create=news

Создался новый файл в директории ~/database/migrations. Открыв этот файл, увидим два метода:
up, который будет вызываться во время наката (выполнения) миграций, и down, который будет
выполняться, если придется откатить миграцию.
Cоздание файла миграций не означает его выполнение.

Фасад Schema — обертка для класса \Illuminate\Database\Schema\Builder.
create — статический метод фасада Schema,
первый параметр - название таблицы,
второй параметр - коллбек,
который в качестве параметра принимает объект класса Illuminate\Database\Schema\Blueprint
Благодаря методам класса Blueprint мы и создаем нужную структуру таблицы внутри самой функции.
У этого класса много методов, подробнее о них: https://laravel.com/docs/5.8/migrations#column
Разберем некоторые из них:
● bigIncrements — создает столбец первичного ключа с автоинкрементом. Принимает в
качестве параметра строку, которая и служит названием столбца;
● timestamps — добавляет в таблицу два столбца: created_at и updated_at;
● string — добавляет в таблицу столбец с типом данных VARCHAR. Первым параметром
принимает строку, которая будет именем столбца. Второй параметр необязательный — длина
строки;
● text — добавляет в таблицу столбец с типом данных TEXT. Первым параметром принимает
строку, которая будет именем столбца;
● json — добавляет в таблицу столбец с типом данных JSON. Первым параметром принимает
строку, которая будет именем столбца;
● bigInteger — добавляет в таблицу столбец с типом данных BIGINT. Первым параметром
принимает строку, которая будет именем столбца;
● dateTime — добавляет в таблицу столбец с типом данных DATETIME. Первым параметром
принимает строку, которая будет именем столбца;
● boolean — добавляет в таблицу столбец с типом данных BOOLEAN. Первым параметром
принимает строку, которая будет именем столбца.

Помимо основных методов, которые определяют тип данных столбца в таблице,
есть модификаторы колонок, которые позволяют установить дополнительные параметры столбца:
● default — метод указывает на то значение, которое будет установлено для колонки по
умолчанию;
● nullable — метод принимает true || false в качестве параметра и указывает, может ли быть
значение в данной колонке null.
● comment — принимает в качестве параметра строку, которая станет комментарием для
указанного столбца.
Данные модификаторы вызываются после определения типа столбца.

sail artisan migrate            //выполнить все миграций, которые есть в папке migrations
                                //(уже выполненные миграции повторно выполняться не будут)

sail artisan migrate:rollback   //отменить все миграции, которые были выполнены в данном предложении
                                //(таблица migrations сохранится).

sail artisan migrate:rollback --step=2      //откатить две последние миграции (указанные в таблице migrations)

В БД кроме таблиц, которые создаются при выполнении миграций, находящихся в папке migrations,
автоматически создаётся таблица migrations.
В таблице migrations хранится информация о тех миграциях, которые были выполнены.


Seeding — посев фейковых данных используется для тестирования приложения

sail artisan make:seeder NewsSeeder     //создать новый seeder
В папке ~database/seeds будет создан новый файл NewsSeeder.php
 — файл одноименного класса, в котором содержится единственный метод run,который будет выполняться при запуске seeder.

 Для заполнения базы данных фейковой информацией воспользуемся библиотекой fzaninotto/Faker.
 Предварительно установим ее через composer — команда для установки библиотеки:
 //устарело
 composer require fzaninotto/faker - библиотека не поддерживается.

 По умолчанию в Laravel входит https://packagist.org/packages/fakerphp/faker

Работа с seeder:
в методе run обращаемся к фасаду DB, который обратится к объекту класса \Illuminate\Database\Query\Builder.
Таким образом мы получим возможность добавлять данные в указанную таблицу.
У полученного объекта вызываем метод insert, который и будет производить данную вставку. Метод insert ожидает массив
данных, в котором ключи будут соответствовать полям таблицы.

Для генерации данных создаем отдельный метод getData и в нем обращаемся к библиотеке, которую
установили.
Обращаемся к статическому методу create и указываем локализацию.
После этого набираем массив из 10 подмассивов.

Каждый подмассив — отдельная строка в базе данных.

Для каждого подмассива собираем фейковые данные.
Для этого используем объект, сохраненный в переменной $faker, и вызываем соответствующие метод:
● sentence — метод класса Faker\Generator, возвращающий предложение, состоящее из указанного количества строк.
В данной библиотеке нет реализации данного метода на русском языке, поэтому результат на английском;
● realText — возвращает указанное количество слов из реального текста, минимум 10 и максимум 200.

Для запуска посева необходимо в консоли выполнить команду
 sail artisan db:seed --class=NewsSeeder
Seeders можно запускать любое количество раз.

Взаимодействие с базой данных
Для взаимодействия с базой данных воспользуемся фасадом DB и его методами.
select - позволяет использовать обычные SQL-запросы c возможностью экранировать данные, полученные от пользователя.
Статический метод Select принимает SQL-запрос, в результате которого получаем массив std-классов.
stdClass в PHP является предопределенным и часто используется для заполнения динамическими свойствами.
В метод select нельзя передавать данные, полученные от пользователя, без предварительной проверки (обработки),
т.к. они небезопасны.
Данные, полученные от пользователя могут содержать SQL-инъекцию (атака на базу данных).
Подробнее о  SQL-инъекциях можно прочитать в статье
https://habr.com/ru/post/148151/

Для защиты SQL-инъекций в Laravel используются подготовленные запросы.
Сначала базе говорится, какой запрос будет происходить, и указывается, куда в запросе нужно подставить данные.
Затем передаются данные и выполняется запрос.
Данные подставляются в строго отведенные им места, что исключает атаку.
Вторым параметром в Select передаем массив, ключом в котором указываем названия плейсхолдеров.
В значении передаем данные для подстановки.

DB::select(
    'SELECT id, title FROM news WHERE id = :id',
    ['id'=>$id]
);
В примере выше в SQL-запросе используется один плейсхолдер :id,
поэтому в массиве содержится одна пара «ключ —значение»: 'id'=> $id.

Помимо статичного метода для получения данных из базы, у фасада DB есть и другие:
● selectOne(string $query, array $bindings = []) — метод для поиска одной записи;
● select(string $query, array $bindings = []) — метод для выборки более чем одной записи;
● insert(string $query, array $bindings = []) — метод для вставки;
● update(string $query, array $bindings = []) — метод для изменения;
● delete(string $query, array $bindings = []) — метод для удаления;
● statement(string $query, array $bindings = []) — метод для запросов, не возвращающих результат.



Конструктор запросов

В практике работы с базой данных использование подхода, описанного выше, допустимо. Но он используется реже, чем
конструктор запросов.

У фасада DB существует метод table('название таблицы'),
возвращающий объект класса Illuminate\Database\Query\Builder.
Он содержит большое количество методов, которые используются для создания запросов к базе данных.
Пример:
$news = DB::table('news')->get();               //извлечь все строки из БД
$news = DB::table('news')->find($id);           //извлечь из БД строку с конкретным id

Примеры использования агрегатных функций count, max, min, avg и sum:
o DB::table('news')->count();
o DB::table('news')->max('id');

Примеры объединения таблиц:
$users = DB::table('users')
    ->join('contacts', 'users.id', '=', 'contacts.user_id')
    ->join('orders', 'users.id', '=', 'orders.user_id')
    ->select('users.*', 'contacts.phone', 'orders.price')
    ->get();

$users = DB::table('users')
    ->leftJoin('posts', 'users.id', '=', 'posts.user_id')
    ->get();

Примеры использования условий: where, orWhere, whereBetween, whereNotBetween, wherein, whereNotIn, whereNull,
whereNotNull, whereDate, whereMonth, whereDay, whereYear:
$users = DB::table('users')->where('votes', '=', 100)->get();

$users = DB::table('users')->where([
    ['status', '=', '1'],
    ['subscribed', '<>', '1'],
    ])->get();

$users = DB::table('users')
    ->where('votes', '>', 100)
    ->orWhere('name', 'John')
    ->get();

$users = DB::table('users')
   ->whereIn('id', [1, 2, 3])
   ->get();





 Конспект вебинара:

 В PHPStorm подключиться к контейнеру Docker можно с использованием вкладки Services,
 которая расположена рядом со вкладкой Terminal.

Значения переменных из контроллеров передаются в шаблоны с помощью сессий.
В контроллере при успешном действии создадим сессию с именем 'success' и выполним редирект на нужную странцу, а шаблон layout её получит и обработает (@if @else):

return redirect()->route('routeName')->with('success', 'message text');

Благодаря использованию сессии 'success' в layout сообщения можно будет выводить на любой странице,
которая использует его.

Чтобы добавить компонент Alert Bootstrap, всплывающий после добавления новости можно использовать "одноразовую" сессию с ключом 'success':
нужно добавить его в layout (в шаблоне страницы у меня не сработал) и
сделать условный рендеринг. Перед этим нужно передать из контроллера ->with('success', "Новость успешно добавлена!").

 @if(session('success'))
    <div>{{ session('success') }} </div>
 @endif



 В   ~/config/database.php хранятся настройки подключения к БД.
 sqlite используется для тестирования.

 Хэлпер env('key', default) берёт значения указанного свойства из файла .env

 При использовании Sail в .env настройки подключения к БД будут такими
 (подключение к БД, которая запущена внутри контейнера Docker):

 DB_CONNECTION=mysql
 DB_HOST=mysql              //? будет использовано дефолтное значение '127.0.0.1', указанное в ~/config/database.php
 DB_PORT=3306
 DB_DATABASE=example_app
 DB_USERNAME=sail
 DB_PASSWORD=password,

 а при работе локально c OpenServer:

 DB_CONNECTION=mysql
 DB_HOST=127.0.0.1
 DB_PORT=3306
 DB_DATABASE=laravel
 DB_USERNAME=root
 DB_PASSWORD=

 Подключиться к БД можно двумя способами: через фасад DB

 В дальнейшем методы для работы с БД должны располагаться в контроллере, а не в модели.
 Извлечение нужных данных будет реализовано средствами БД, а не PHP.

 Для упрощённого просмотра БД в контейнере Docker можно использовать HeidiSQL.
В настройках подключения к БД HeidiSQL требуется указать имя хоста/IP
(в .env указано DB_HOST=mysql).
Чтобы определить внешний IP-адрес контейнера Docker Sail в виртуальной среде Linux,
командная строка которой появляется после ввода команды wsl,
ввести команды:
$ sudo apt install net-tools
$ ifconfig
Эта команда выведет параметры сети внешнего eth0 и внутреннего lo соединений.
Нам требуется внешний ip-адрес контейнера.
У меня он 172.17.88.101.
Остальные данные для настройки подключения в HeidiSQL я взял в .env.

Чтобы реализовать возможность работы над одним проектом нескольких разработчиков с помощью Git,
используется механизм миграций.
Таблицы создаются с помощью PHP-команд.
Каждой таблице в БД соответствует отдельный PHP-файл.
Это позволяет всем разработчикам иметь актуальную версию БД после git pull.

Для создания миграций используются библиотеки.
В Laravel библиотека для создания миграций входит по умолчанию.
Laravel/Database/Getting started

Перед выполнением миграций нужно вручную создать пустую БД, например, при развёртывании проекта на хостинге.
Имя БД должно совпадать с указанным в .env

Чтобы создать структуру БД нужно создать файлы миграций, а затем их выполнить.
По умолчанию в Laravel имеется несколько миграций: ~/database/migrations/,
в том числе, для создания таблицы users.

Файлы миграций (заготовки)  создаются с помощью команды
$ sail artisan make:migration name_migration

Команда создания модели автоматически с ключом -m автоматически создаёт и миграции для неё:
$ sail artisan make:model ModelName -m

Имя файла миграции должно содержать имя таблицы и описывать то, что с ней происходит:
create - создание таблицы
 //создание таблицы новости
$ sail artisan make:migration create_news_table

//добавление столбца category_id в таблицу news
$ sail artisan make:migration alter_table_news_add_column_category_id

Для добавления связей между таблицами (внешних ключей) нужно, чтобы типы данных связываемых столбцов были одинаковыми.

Пример миграции для изменения типа данных столбца (->change()) с установкой дефолтного значения (default()):
$table->unsignedBigInteger('category_id')->default(1)->change();

Laravel 8
Метод foreignId создает эквивалент столбца UNSIGNED BIGINT, в то время как метод constrained будет использовать соглашения для определения имени таблицы и столбца, на которые ссылаются. Если имя вашей таблицы не соответствует соглашениям Laravel, вы можете указать имя таблицы, передав его в качестве аргумента методу constrained:

Schema::table('posts', function (Blueprint $table) {
    $table->foreignId('user_id')->constrained('users');
});


Для автоматического каскадного удаления всех строк БД при удалении строки, на которую ссылается их внешний первичный
ключ, используется метод ->restrictOnDelete().
Также существует ->restrictOnUpdate().

Создание внешнего ключа таблицы
$table->foreign('foreign_key')->references('column_name')->on('table_name');    ->restrictOnDelete() для каскадного
удаления данных

Миграции создают связи между данными на уровне БД, но модели об этом пока ничего не знают.
Нужно организовать связи между данными на уровне моделей, что позволит использовать все преимущества ORM.
Чтобы, например, из новости получать её категорию,
или по id категории получить все новости этой категории.
В Laravel связи между моделями называются отношениями.
Средствами Laravel могут быть реализованы связи:
 один ко многим     - $this->belongsTo(Category::class, 'id' )->first();
 многие ко многим   - $this->hasMany(class, property_name)

 Например, в модель Category нужно добавить метод, возвращающий все новости этой категории
   //название метода соответствует классу, с которым создаётся связь
     public function news()
     {
        //->has_Many() свяжет внешний ключ (category_id) указанного класса (News) с первичным ключом класса (Category),   в котором   создаётся    метод.
         return $this->hasMany(News::class, 'category_id');
     }
 Тогда, чтобы получить массив связанных новостей,
 из родительского класса Category можно обратиться к свойству:
     $category->news,
 или использовать метод:
     $category->news()->get()


А в модель News добавить метод, возвращающий категорию соответствующей новости:
  //название метода соответствует классу, с которым создаётся связь
    public function category()
    {
        //->belongsTo() свяжет внешний ключ category_id класса, в котором создаётся метод (News), с первичным ключом     класса,     указанного в    первом параметре (Category)
        return $this->belongsTo(Category::class, 'category_id' )->first();
    }

Для выполнения миграций (внесения изменений в структуру БД) нужно выполнить команду:
$ sail artisan migrate

Для "отката" изменений, внесённых в БД последней миграцией
(командой $ sail artisan migrate)
используется команда:
$sail artisan migrate:rollback

Для добавления столбца category_id  в таблицу news необходимо создать миграцию командой:
sail artisan make:migration add_category_id_column_to_news_table --table=news

Для заполнения таблиц фейковыми данными используется "посев" Seeding
Seeders располагаются в ~/database/seeders/

Фабрики сидеров находятся в ~/database/factories/ - с помощью них удобно производить "посев". Пока обойдёмся без них.

Для создания файла для заполнения БД данными используется команда:
$ sail artisan make:seeder TableNameSeeder      //на первом месте - название таблицы + Seeder

В ~/database/seeders/DatabaseSeeder.php и во всех сидерах имеется метод run((), который выполняет "посев".

Библиотека Faker предустановлена в Laravel по-умолчанию (composer.json).
Документацию по Faker можно найти на сайте  https://packagist.org/.
Внутри сидера новостей создадим метод getData(), который будет возвращать случайные данные (с помощью Faker),
которыми будет заполняться таблица БД.

Если требуется подключить Faker в проект, лучше всего это делать в
~/app/Providers/AppServiceProvider.php в
    public function boot()
    {
    //подключает пагинатор Bootstrap
        Paginator::useBootstrap();

        //не тестировал
        //создаёт локализованный для русского языка экземпляр класса Faker.
        Faker\Factory::create('ru_Ru');
    }
    После этого один экземпляр русифицированного Faker будет доступен во всех классах приложения, а не создаваться в
    каждом классе заново.

Если Seeder или другой класс не подключается автоматически (не попадает в автозагрузчик),
возникает ошибка "Класс не найден",
то нужно выполнить команду:

composer dump-autoload

Пример Seeder:
<?php
namespace Database\Seeders;

use Illuminate\Database\Seeder;
use Faker;
use Illuminate\Support\Facades\DB;

class NewsSeeder extends Seeder
{
    /**
     * Run the database seeds.
     *
     * @return void
     */
    public function run()
    {
        DB::table('news')->insert($this->getData());
    }

    public function getData()
    {
        $data = [];
        //создаёт локализованный для русского языка экземпляр класса Faker.
        $faker = Faker\Factory::create('ru_Ru');
        //для создания массива новостей используем цикл
        for ($i = 0; $i < 5; $i++) {
            $data[] = [
                'title' => $faker->realText(rand(10, 30)),
                'text' => $faker->realText(rand(1000, 3000)),
                'isPrivate' => $faker->boolean()
            ];
        }
        return $data;
    }
}

  $faker = Faker\Factory::create('ru_Ru');      //создаёт локализованный для русского языка экземпляр класса Faker.

  Если обращаться к БД напрямую (не использую фасад DB), то будет утеряно кэширование и безопасность и т.п.,
  предоставляемые  фреймворком.

      /*  DB::table('tableName')->insert(массив или массив массивов);
        Если передать один массив - то в таблицу будет добавлена одна строка и метод вернёт её id,
        если передать массив массивов, то будет добавлено число строк, равное количеству элементов внешнего массива.*/
        DB::table('news')->insert($this->getData());

Для запуска сидера используется команда:
$ sail artisan db:seed --class=ClassNameSeeder,
где ClassNameSeeder - название класса сидера.

Если используется ORM-модель, то для сидинга удобнее использовать фабрики классов, например,
~/database/factories/UserFactory
.php.
Для этого в корневом сидере ~/database/seeders/DatabaseSeeder.php в методе run() у нужной модели нужно вызывать
статический метод NeedModel::factory(count)->create()

Например:
public function run()
{
\App\Models\User::factory(10)->create();   //засеет в БД 10 пользователей
\App\Models\User::factory()->create([      //засеет в БД одного пользователя с нужными параметрами, например Admin
    'name'=>'Alex',
    'email'=>'alex@example.com',
]);
$this->call(CategorySeeder::class);         //вызов сидеров остальных таблиц.
}

Если в БД много таблиц, то выполнять посев данных в каждую из них отдельной командой затратно, поэтому используется
класс DatabaseSeeder, который присутствует в Laravel по умолчанию и содержит метод run().
Последовательность запуска сидеров внутри run() имеет значение:
сначала нужно засеивать таблицы, столбцы в которых не ссылаются на другие таблицы
(т.к. сначала таблица категорий, а потом таблица новостей, которые относятся к категориям),
чтобы избежать ошибок.

        //вызов нужного seeder
        $this->call(NewsSeeder::class);

//Очистить БД, перезапустить миграции, засеять БД данными
$ sail artisan migrate:fresh --seed

Чтобы извлечь данные из БД нужно использовать фасад DB.
Например:
$news = DB::select('SELECT * FROM `news` WHERE 1');     //возвращает объект
Использовать метод select можно только в исключительных случаях,
когда невозможно обойтись средствами конструктора запросов.

Методы фасада DB (например get()) возвращают коллекции,
т.е. массивы, элементы которых являются объектами, содержащими данные и методы
для работы с ними.
Чтобы преобразовать их в массив, можно использовать метод ->get()->toArray(),
но делать это не рекомендуется, т.к. теряется гибкость,
кроме того, лишние действия снижают производительность приложения.

get()       - возвращает все данные из таблицы,
find($id)   - возвращает строку таблицы с id = $id.

  StyleGuide:
  имена классов сущностей называть в единственном числе (каждый экземпляр модели содержит одну запись БД) с заглавной
  буквы,
  а таблицам, хранящим данные этих сущностей, во множественном с маленькой.

Механизм миграций реализует функционал системы контроля версий при работе с БД.
Миграции позволяют собирать БД вне зависимости от исходного состояния,
т.к. при запуске миграции будут выполняться только те, которые ещё не выполнялись (новые).

sail artisan migrate:fresh      //удалить все таблицы из БД и запустить все миграции

 В ~/database/migrations/ хранятся файлы миграций.
 В каждой миграции есть методы:
  up() - для внесения изменений в БД
  down() - для отката изменений.

  метод ->id() создаёт первичный ключ (автоинкремент, всё что нужно),
  ранее вместо него использовался метод ->bigIncrements('id').
  ->default(value) - дефолтное значение
  ->comment(string)- комментарий к названию столбца
  ->string(string) - короткая строка
  ->text(string) - длинный текст
  Методы для создания полей подробно описаны в документации на сайте в разделе Migrations.
  00:40 - пример создания миграции (применение методов для создания полей нужных типов).


1. Продумать структуру сохранения данных следующих таблиц:
a. Новости.
b. Категории новостей по образцу.
c. Источники получения новостных данных.
Структура может быть реализована в виде рисунка, таблиц или специальных диаграмм.

2. Сделать миграции для таблиц из первого задания. Миграции должны иметь роллбеки.
sail artisan make:migration create_categories_table
sail artisan make:seeder CategoriesSeeder


3. С помощью сидинга реализовать заполнение созданных таблиц фейковыми данными.
Таблица категорий — минимум 5 записей. Таблица новостей — минимум 10 записей на
каждую категорию. Таблица источников — минимум 10 записей.

4. Удалить созданные методы в контроллере для хранения данных и реализовать вывод данных
из базы.

Связи между таблицами делать не нужно.
Подумать как извлечь новости конкретной категории.

Нужно переделать метод create() в Adminj\NewsController.php.
Вместо Storage::disk() - insert(),
если идёт редирект на эту новость, то insertGetId() - возвращает id добавленной записи.
Подробнее о ДЗ 1:31, 1:33
Продолжить просмотр с 1:39 (добавление картинки в HTML)

Чтобы файлы, находящиеся в папке ~/storage стали доступны в браузере,
нужно создать символическую ссылку (ярлык) командой:
$ sail artisan storage:link
   INFO  The [public/storage] link has been connected to [storage/app/public].

   Публичный диск
   Диск public, включенный в filesystems файл конфигурации вашего приложения, предназначен для файлов, которые будут
   общедоступны. По умолчанию public диск использует local драйвер и хранит свои файлы в формате storage/app/public.

   Чтобы сделать эти файлы доступными из Интернета, вы должны создать символическую ссылку с public/storage на
   storage/app/public. Использование этого соглашения о папках позволит хранить ваши общедоступные файлы в одном каталоге, который можно легко использовать в разных развертываниях при использовании систем развертывания с нулевым временем простоя, таких как Envoyer .

   Чтобы создать символическую ссылку, вы можете использовать команду
   storage:link Artisan:

   php artisan storage:link

   После сохранения файла и создания символической ссылки вы можете создать URL-адрес файлов с помощью asset помощника:

   echo asset('storage/file.txt');

   Вы можете настроить дополнительные символические ссылки в filesystems файле конфигурации. Каждая из настроенных
   ссылок будет создана при выполнении storage:link команды:

   'links' => [
       public_path('storage') => storage_path('app/public'),
       public_path('images') => storage_path('app/images'),
   ],

Конспект лекции №6: Работа с базой данных. Eloquent ORM. Laravel Debugbar

Laravel Debugbar - внешний компонент. Его аналог присутствует в Laravel UI.
Помогает получать большое количество отладочной информации (например, Request) прямо в окне браузера без использования dump().

Искать на packagist.org (barryvdh/laravel-debugbar)
sail composer require barryvdh/laravel-debugbar --dev

ORM (англ. Object-Relational Mapping, рус. объектно-реляционное отображение, или преобразование) — технология программирования, которая связывает базы данных с концепциями объектно-ориентированных языков программирования, создавая «виртуальную объектную базу данных».

DB:: - надстройка над библиотекой PDO

Создать модель extends Model:
sail artisan make:model ModelName

Более правильный способ создания модели - использование параметра -m, который автоматически создаёт миграцию для
создаваемой модели:

$ sail artisan make:model Category -m
   INFO  Model [app/Models/Category.php] created successfully.
   INFO  Created migration [2022_11_21_113456_create_categories_table]


use HasFactory внутри тела класса означает использование трейта HasFactory.

Класс Model имеет большое количество полей, например:
    protected $table;               название таблицы
    protected $primaryKey = 'id';   первичный ключ
в классе наследнике их можно переопределять.

Создание класса модели (даже созданного по умолчанию - без редактирования)
позволяет использовать ORM, т.к. на самом деле он не пуст, потому что встроенный в Laravel класс Model, от которого наследуются пользовательские модели, имеет большое количество полей и методов для работы с ними:
для получения данных из БД вместо фасада DB использовать фасад,
соответствующий названию класса модели.
Например:
$news = DB::table('news')->get();
идентично
$news = News::all();    //возвращает коллекцию - массив объектов класса-модели
Каждый объект коллекции содержит не только данные, но и методы для работы с ними.

$news = DB::table('news')->find($id);
идентично
$news = News::query()->find($id);
метод query() берёт имя таблицы из самой модели News.

ORM упрощает использование маршрутов с параметрами.
Если имя параметра в маршруте совпадает с именем модели (/{news}), и в методе контроллера в качестве параметра
используется
название модели (News $news), то в контроллере будет создан (вернее, получен из контейнера) не пустой объект News, а
соответствующий переданному в маршруте параметру.
Т.е. из БД будет возвращаться строка со значением первичного ключа, равным переданному в адресной строке браузера, либо
произойдёт перенаправление на страницу '404'.
Кроме того, в представлениях в динамических маршрутах, в которых используются экземпляры класса-модели, не требуется
указывать первичный ключ таблицы, т.к. Laravel извлечёт его и подставит в маршрут по-умолчанию.
Например:
href="{{ route('news.show', $item->id) }}"
идентично
href="{{ route('news.show', $item) }}",
т.е. разработчику не требуется помнить название первичного ключа модели.

Cтандартные методы создания моделей Eloquent - make(), create(), update() и save().

firstOrNew() - поиск первой модели, которая соответствует некоторым ограничениям, или для создания новой, если такой
модели нет.
$user = User::firstOrNew(['email' =>  request('email')]);
$user->name = request('name');
$user->save()

firstOrCreate() - пытается найти модель, соответствующую атрибутам, которые вы передаете в первом параметре. Если модель не найдена,
 автоматически создает и сохраняет новую модель после применения любых атрибутов, переданных во втором параметре.
$user = User::firstOrCreate(
    ['email' =>  request('email')],
    ['name' => request('name')]
);
// No call to $user->save() needed

firstOr() - извлекает первую модель из запроса или, если подходящая модель не найдена, вызывает переданный обратный вызов. Это может быть очень полезно, если вам нужно выполнить дополнительные шаги при создании пользователя или вы хотите сделать что-то кроме создания нового пользователя
$user = User::where('email', request('email'))->firstOr(function () {
    $account = Account::create([ //... ]);

    return User::create([
        'account_id' => $account->id,
        'email' => request('email'),
    ]);
});

updateOrCreate() - пытается найти модель, соответствующую ограничениям, переданным в качестве первого параметра. Если будет найдена подходящая Модель, она обновит совпадение с атрибутами, переданными в качестве второго параметра. Если подходящая модель не найдена, будет создана новая модель с ограничениями, переданными в качестве первого параметра, и атрибутами, переданными в качестве второго параметра.
$user = User::where('email', request('email'))->first();
if ($user !== null) {
    $user->update(['name' => request('name')]);
} else {
    $user = User::create([
      'email' => request('email'),
      'name' => request('name'),
    ]);
}
// Do other things with the User

Принцип работы фасада - при необходимости будет создан экземпляр класса и помещён в контейнер.
При повторном обращении к классу новый экземпляр создаваться не будет, а будет браться из контейнера.

Пример запроса с использованием ORM (AR):
выводит неприватные новости:
$news = News::query()->where('isPrivate', false)->get();
сработает даже так:
$news = News::where('isPrivate', false)->get();


Пагинация.

$news = News::query()->paginate($n); - возвращает не коллекцию, а объект paginator, одним из свойств которого является
коллекция объектов нужного класса. Кроме того, имеются методы для работы с данными объекта:
{{ $news->links() }} - по умолчанию в шаблоне для пагинации будут использованы стили TailWind, но их можно изменить на
пользовательские.
Для применения пользовательских стилей к пагинации можно в ~/app/Providers/AppServiceProvider.php зарегистрировать новые
компоненты функционала в методе register(), а в методе boot() указать инициализации, которые будут происходить при
загрузке.
Paginator::useBootstrap(); //применить стили Bootstrap к пагинации при загрузке


Работа с коллекциями

Хэлпер collect([]) возвращает объект класса-коллекции Illuminate\Support\Collection, который имеет очень много методов
для работы с данными, которых не имеют обычные массивы, например, найти дубли, объединять, count, min, max, last, first,
 sort и т.п..
 Например:
 ->keyBy('id'); // позволяет привести первичные ключи коллекции (аналог номеров элементов в массиве) в соответствие
 указанному в качестве параметра ключу объектов, входящих в
 коллекцию.
 ->diff();      //найти отличия

$collection = collect([1,2,3]);

Если не использовать библиотеку Laravel/UI, то пользовательские стили (в том числе и Bootstrap) и  скрипты нужно
подключать в теге
head:
<script src="{{ asset('js/app.js' }}" defer></script>
<link href="{{ asset('css/app.js' }}" rel="stylesheet"></script>

Вместо ->get()[0] пишите first()

Плюсом использования ORM является дополнительная защита от изменения данных, т.к. модель этого не даст.
Чтобы получить возможность изменять данные в модели, нужно внутри неё создать protected свойство $fillable = []. В
массиве свойства $fillable нужно указать свойства модели, которые будет разрешено изменять.
Тогда этот блок команд сохранит в модель только те данные из класса Request, которые перечислены в свойстве fillable:
       $data = $request->all();     //получение всех данных объекта класса Request
       $news->fill($data);          //заполнение только тех полей экземпляра класса News, которые перечислены в его
       свойстве fillable
       $news->save();               //Сохранение строки в БД

После этого, согласно паттерну Active Record,
$id = $news->id; //метод ->save() заполнит значение id полученным из БД номером строки?

->save() понимает, с новой или старой записью мы работаем, поэтому операции CRUD Create и Update в Laravel выглядят
практически одинаково.

При выполнении операции CRUD Delete, метод delete() возьмёт id из свойства объекта, с которым совершается операция:
$news->delete()

StyleGuide
Название метода контроллера, название маршрута, название представления (view) должны совпадать.

Для разграничения действий с ресурсами на уровне HTTP-методов и были придуманы следующие варианты:
GET — получение ресурса
POST — создание ресурса
PUT — обновление ресурса
DELETE — удаление ресурса

Чтобы реализовать отправку запроса методом DELETE в HTML кнопку нужно обернуть в тег form,
создать скрытое поле (hidden), в котором указать HTTP-метод.

Для редактирования новости повторно используем форму добавления новости.
Для назначения правильного маршрута обработчика в теге форм будем использовать тернарный оператор, который проверяет
наличие свойства id в объекте $news (если мы создаём новость, то объект будет пуст):

 <!-- Если $news содержит поле id, значит мы не создаём новость, а редактируем-->
<form id="news__add"
action="{{ $news->id ? route('admin.update', $news): route('admin.create') }}"
method="post">

Тернарный оператор удобно использовать и в заголовках формы:
 <div>
{{$news->id ? 'Редактировать' : 'Добавить'}} новость
</div>

Также для реализации редактирования новости в одной форме с созданием,
в тегах input нужно использовать оператор сравнения с null ??:
  <input name="title" value="{{ $news->title ?? old('title') }}">
  если заголовок новости пуст, то, при наличии, будет выведено старое значение.

Чтобы изменить метод отправки данных формой с POST на, например, DELETE, нужно внутри формы добавить директиву @method()
<form method="post">
 @csrf
 @method('DELETE')
</form>


Контроллеры ресурсов
https://laravel.com/docs/9.x/controllers#resource-controllers\

Также доступны

Частичные маршруты ресурсов
Вложенные ресурсы
Именование ресурсных маршрутов
Именование параметров маршрута ресурса
Обзор маршрутов ресурсов
Локализация URI ресурсов
Дополнение контроллеров ресурсов

Создание ResourceController (контроллера ресурсов)
sail artisan make:controller NameController -r
тогда все маршруты CRUD можно будет заменить одной строкой:
Route::resource('modelname', 'ModelController');

Маршрутизация ресурсов Laravel назначает типичные маршруты
«CRUD» контроллеру с помощью одной строки кода. Например, вы можете создать контроллер,
который будет обрабатывать все HTTP-запросы для «фотографий», хранящихся в вашем приложении. С помощью команды make:controllerArtisan мы можем быстро создать такой контроллер:

php artisan make:controller PhotoController --resource

Эта команда сгенерирует контроллер в app/Http/Controllers/PhotoController.php. Контроллер будет содержать метод для каждой из доступных операций с ресурсами.
Далее вы можете зарегистрировать ресурсный маршрут к контроллеру:

Route::resource('photos', 'PhotoController');

Verb	URI 	                Action	Route Name
GET	    /photos	                index	photos.index
GET	    /photos/create	        create	photos.create
POST	/photos	                store	photos.store
GET	    /photos/{photo}	        show	photos.show
GET	    /photos/{photo}/edit    edit	photos.edit
PUT     /PATCH/photos/{photo}	update	photos.update
DELETE	/photos/{photo}	        destroy	photos.destroy





Урок 7. Валидация
данных в Laravel
Возможность Laravel валидировать данные, полученные из
запроса пользователя.

Валидация — это проверка данных на соответствие заданным условиям и ограничением.

Способы валидации:
https://laravel.demiart.ru/ways-of-laravel-validation/

В Laravel есть несколько подходов для проверки данных. Базовый вариант — валидация данных в контроллере при помощи набора правил.
Базовый контроллер содержит трейт ValidatesRequests, в котором есть метод validate.
Этот вариант реализуется в контроллерах, которые в качестве параметра принимают Request.
Валидацию необходимо выполнять в момент получения данных из формы:
        $this->validate($request, className::rules()),
        где rules() - это метод, возвращающий массив правил (его нужно создать в модели).
        Набор правил можно сразу передать вторым параметром в метод
        $this->validate($request, [rules]); - это более распространённый и наглядный способ.
        Кроме того можно передать необязательные параметры:
        массив сообщений и массив пользовательских атрибутов.

Полезные правила валидации
confirmed - проверяемое поле должно иметь соответствующее поле {field}_confirmation.
Например, если проверяется поле password, во входных данных должно присутствовать соответствующее поле
password_confirmation.
SO ?По умолчанию «подтвержденный» валидатор Laravel добавляет сообщение об ошибке в исходное поле, а не в поле, которое
обычно содержит подтвержденное значение.?

current_password - проверяемое поле должно совпадать с паролем аутентифицированного пользователя.
Вы можете указать защиту аутентификации , используя первый параметр правила:
'password' => 'current_password:api'

  Доступные правила валидации:
  https://laravel.com/docs/9.x/validation#available-validation-rules-

В результате работы метода validate() в шаблоне становится доступной переменная $errors.
  Значение переменной  $errors, которая ссылается нао объект, который заполняется результатами работы метода validate() можно вывести в шаблон,
  но  только между секциями
     @dump($errors)

     Получить доступ к массиву ошибок в объекте $errors можно с помощью методов:
$errors->has('text'): boolean - проверяет наличие в массиве ошибок, связанных с элементом формы, имещюм name="text";
$errors->get('text') :[string] - возвращает массив строк с описанием ошибок тега с указанным name="text"
$errors->all():[string] - возвращает плоский массив строк ошибок, содержащий ошибки всех тегов, независимо от имени

Если перебрать массив ошибок в шаблоне, то текст ошибки можно получить так:
@if($errors->has('text'))
    @foreach($errors->get('text') as $error)
        <label for="news__title"                                                          class="{{ $error ? 'text-danger':''}}">
         {{ $error }}
         </label>
    @endforeach
@endif

В Blade есть директива, которая позволяет вывести одну ошибку в шаблон:
@error('tag_name')
{{$message}}
@enderror

В Laravel имеется класс ~/vendor/laravel/framework/src/Foundation/Validation/ValidatesRequests.php, в котором есть метод
 public validate():

    * Validate the given request with the given rules.
      *
      * @param  \Illuminate\Http\Request  $request
      * @param  array  $rules
      * @param  array  $messages
      * @param  array  $customAttributes
      * @return array
      *
      * @throws \Illuminate\Validation\ValidationException
      */
     public function validate(Request $request, array $rules,
                              array $messages = [], array $customAttributes = [])
     {
         $rules = $request->isPrecognitive()
             ? $request->filterPrecognitiveRules($rules)
             : $rules;

         $validator = $this->getValidationFactory()->make(
             $request->all(), $rules, $messages, $customAttributes
         );

         return tap($validator, function ($validator) use ($request) {
             if ($request->isPrecognitive()) {
                 $validator->after(Precognition::afterValidationHook($request));
             }
         })->validate();
     }


Чтобы сохранить контроллер "тонким" валидацию можно выполнять в отдельном классе:
sail artisan make:request StoreNewsRequest
Request [app/Http/Requests/StoreNewsRequest.php] created successfully.

Тогда массив rules нужно перенести из контроллера в public function rules() созданного класса, а в самом контроллере
можно использовать
$validated = $request->validated(); возвращающий данные, прошедшие проверку.
//получить часть данных
 $validated = $request->safe()->only(['name', 'email']);
 $validated = $request->safe()->except(['name', 'email']);

Если проверка не пройдена, будет сгенерирован ответ перенаправления, чтобы отправить пользователя обратно в его предыдущее местоположение.
Ошибки также будут переданы в сеанс, чтобы они были доступны для отображения.
Если запрос был запросом XHR, пользователю будет возвращен ответ HTTP с кодом состояния 422, включая JSON-представление ошибок проверки.

В public function rules() нужно обрабатывать запросы всеми HTTP-методами, используя switch ($this->method()){ case }.
public function rules()
    {
    switch ($this->method()) {
        case 'GET':
        case 'DELETE': {
            return [
              'id'=>'required|exists:posts,id'
            ];
        }
        case 'POST': {
            return [
            'title'=> 'required|min:10',
            'description' => 'required'
            ];
        }
        case 'PUT':
        case 'PATCH': {
            return [
              'id'=>'required|exists:posts,id'
            'title'=> 'required|min:10',
            'description' => 'required'
            ];
        }
        default:
            break;
    }
    }


Локализация Laravel

В папке ~/lang/ находятся папки с языковыми пакетами (локалями).
В них в том чиле хранится файл с текстами ошибок валидации: validation.php

Также зыковые пакеты можно устанавливать выборочно, вручную скопировав нужный файл:
php-файлы языковых пакетов должны храниться в подпапках ~/lang/,
JSON-файл языковых пакетов должны располагаться непосредственно в каталоге  ~/lang/.

Язык по умолчанию для приложения хранится в параметре config/app.php конфигурации файла locale конфигурации

Язык по-умолчанию можно переключить для одного запроса методом
App::setLocale($locale);

Языковые пакеты можно установить с помощью Composer (огромное количество языков).
Например, Laravel Lang (92? языка).
Вручную установить языковой пакет из Laravel Lang не получится.
Для установки одного языка из Laravel Lang требуется предварительно установить Laravel Lang Publisher:
sail composer require laravel-lang/publisher laravel-lang/lang laravel-lang/attributes --dev
Скопировать папки с нужными пакетами из GitHub в ~/lang/
Выполнить команду:
sail artisan vendor:publish --provider="LaravelLang\Publisher\ServiceProvider"
Для установки нужного пакета выполнить команду:
sail artisan lang:add ru
При этом будет создан файл ru.json
Доступтные команды Laravel Lang Publisher:
  ⇂ lang:add
  ⇂ lang:reset
  ⇂ lang:rm
  ⇂ lang:update
  ⇂ migrate:install
  ⇂ sail:install
  --force нужно добавлять для удаления защищённого пакета

Получить строку перевода из файла языкового пакета php:
{{ __('messages.welcome') }}, где messages - имя файла, а welcome - ключ массива

Получить строку перевода из файла языкового пакета json
(используются строки перевода по умолчанию в качестве ключей перевода):
{{ __('I love programming') }}, где I love programming - строка в файле json.

Сбросить кэш Laravel:
sail artisan cache:clear


Тестирование форм. Тестирование автоматического поведения.

Laravel Dusk предоставляет выразительный и простой в использовании API для автоматизации и тестирования браузера. По умолчанию Dusk не требует установки JDK или Selenium на локальный компьютер. Вместо этого Dusk использует автономную установку ChromeDriver .

!!! Вы никогда не должны регистрировать его в своей производственной среде, так как это может привести к тому, что
произвольные пользователи смогут пройти аутентификацию в вашем приложении!!!

sail composer require --dev laravel/dusk
sail artisan dusk:install
ChromeDriver binary successfully installed for version 107.0.5304.62.

Затем установите APP_URL  переменную среды в .env файле вашего приложения. Это значение должно соответствовать URL-адресу, который вы используете для доступа к своему приложению в браузере.

Как настроить Laravel Dusk на Laravel Sail или docker
https://dev.to/georgykurian/how-to-run-laravel-dusk-on-laravel-sail-docker-with-a-custom-database-3olk

Запуск тестов
Laravel предоставляет потрясающую поддержку тестирования «из коробки», и вы можете использовать testкоманду Sail для запуска функциональных и модульных тестов приложений.
Любые параметры CLI, которые принимает PHPUnit, также могут быть переданы в test команду:
sail test
эквивалентно
sail artisan test

Благодаря Sail вы можете запускать эти тесты, даже не устанавливая Selenium или другие инструменты на свой локальный
компьютер. Для начала раскомментируйте сервис selenium в docker-compose.yml файле вашего приложения:

selenium:
    image: 'selenium/standalone-chrome'
    volumes:
        - '/dev/shm:/dev/shm'
    networks:
        - sail

Затем убедитесь, что laravel.test служба в docker-compose.yml файле вашего приложения имеет depends_on запись для
selenium:

depends_on:
    - mysql
    - redis
    - selenium

Наконец, вы можете запустить набор тестов Dusk, запустив Sail и выполнив dusk команду:
sail dusk

Запустить упавшие тесты:
sail artisan dusk:fails

При возникновении ошибки:
1 / 1 (100%)file_put_contents(/var/www/html/.phpunit.result.cache): Failed to open stream: Permission denied
самый простой способ решить проблему - удалить файл .phpunit.result.cache из корневой папки проекта.

По умолчанию Sail создаст выделенную testing базу данных, чтобы ваши тесты не мешали текущему состоянию вашей базы данных
. При установке Laravel по умолчанию Sail также настроит ваш phpunit.xml файл для использования этой базы данных при выполнении ваших тестов:

<env name="DB_DATABASE" value="testing"/>

Тесты можно создавать по образцу: ~/tests/Browser/ExampleTest.php
Если тест не будет пройден, то в папке ~/tests/Browser/screenshots появится скриншот.

Создать новый тест браузера Dusk:
sail artisan dusk:make AdminNewsTest

Имена методов тестов должны описывать их назначение.

При выполнении тестов возможна ситуация, при которой валидация будет успешно пройдена и тестовые данные будут заненсены
в БД. Чтобы не засорять Production-БД для тестов используют другую БД.
При использовании для тестирования отдельной БД в методах теста нужно предварительно
выполнять миграции и засеивать БД, т.к. изначально она пуста и это будет вызывать ошибки
при попытке обращения к ней. Это можно сдалать выполнив команды:

$this->artisan('migrate:fresh');
$this->artisan('db:seed)';

или использовав один из Trait:
\Illuminate\Foundation\Testing\RefreshDatabase - если не требуются сиды
\Database\Seeders\DatabaseSeeder
Эти трейты позволяют перед запуском тестов запускать миграции или посев.

Чтобы данные тестов не засоряли рабочую БД,
в .env.dusk нужно изменить (указать следующие) настройки подключения к БД:
DB_CONNECTION=mysql
DB_HOST=127.0.0.1
DB_PORT=3306
DB_DATABASE=test
DB_USERNAME=root
DB_PASSWORD=


Чтобы запустить проект Laravel Sail локально, достаточно скопировать папку проекта в каталог OpenServer и сделать
соответствующие настройки окружения в OpenServer:
версии PHP, имя домена?

Чтобы реинициализировать БД при каждом запуске теста в класс теста нужно добавить трейт
use RefreshDatabase
(см. методичку).
Это приведёт к тому, что запись, добавленная в БД после запуска теста, при следующем запуске теста будет удаляться.

Более правильный вариант работы тестов с БД -
чтобы не писать тестовую информацию в рабочую БД, нужно создать файл .env.dusk.{environment} и в нём описать подключение к тестовой БД.
Если в папке проекта имеется файл .env.dusk, то настройки, указанные в нём будут использоваться при запуске тестов.
При работе с Sail в .env.dusk нужно указать параметр
APP_URL=http://laravel.test

Практическое задание
1. Добавить валидирование данных, которые получены из форм, созданных на предыдущих
уроках.
2. Используя знания, полученные на уроке, реализуйте вывод сообщений об ошибках валидации полей форм (из задания 1).
3. Добавьте тесты — минимум по две проверки на каждую форму

Завалидировать все формы, кроме формы логина.
Осталось сделать валидацию формы CRUD категорий, а также закончить валидацию остальных HTTP-методов формы новостей (без
дублирования - нужно делать валидацию в модели или отдельном классе).

Сделать проверку, чтобы не было возможности добавить в БД уже существующую категорию (по аналогии с полем id).
В форме ввода логина изменить правила, чтобы можно было использовать пароль из 3 символов.

Сделать по 1-2 теста на каждую форму:
вбить данные во все поля (->type() для каждого поля формы),
нажать на кнопку Добавить,
проверить, работает ли валидация,
видит ли браузер ошибки валидации (-assertSee()).

ToDo набить руку на создании CRUD-операций: роут - контроллер - модель - работа с БД и формой.
ToDo посмотреть англоязычные ролики по Laravel Inertia

Помощь преподавателя по установке Dusk

sail artisan dusk --do-not-cache-result
wget -q -O - https://dl-ssl.google.com/linux/linux_signing_key.pub | sudo apt-key add -
sudo sh -c 'echo "deb [arch=amd64] http://dl.google.com/linux/chrome/deb/ stable main" >> /etc/apt/sources.list.d/google-chrome.list'
sudo apt-get update && sudo apt-get install -y google-chrome-stable
sudo apt-get install -y xvfb

Обновить chromdriver на Ubuntu:
version=$(curl -s "https://chromedriver.storage.googleapis.com/LATEST_RELEASE")
wget -qP /tmp/ "https://chromedriver.storage.googleapis.com/${version}/chromedriver_linux64.zip"
sudo unzip -o /tmp/chromedriver_linux64.zip -d /usr/bin

Разрешения должны быть 755по умолчанию, но если это не так, вы можете запустить:
sudo chmod 755 /usr/bin/chromedriver


В итоговом варианте для учётной записи админа сделать
логин admin@admin.ru
пароль 123
и заполнить ими атрибуты value соответствующих инпутов.

Урок 8. Посредники.Сессии в Laravel.Аутентификация. Авторизация и идентификация пользователей.
Разграничение прав доступа к информации

Аутентификация и авторизация
 Аутентификация — это проверка введенных логина и пароля, а также данных зарегистрированных
 пользователей в системе. В Laravel предусмотрена своя система аутентификации, которая работает
 практически из основной сборки. В этом уроке рассмотрим версию фреймворка 6.0.

 Авторизация — предоставление лицу или группе лиц прав на выполнение определенных действий, а
 также процесс проверки (подтверждения) данных прав при попытке выполнения этих действий.

 Посредники (middleware) — специальные классы Laravel, предназначенные для выполнения пред- и
 постобработки запроса пользователя.
 Прежде чем достигнуть контроллера, HTTP-запрос может пройти через ряд посредников.
 Посредники запускаются по цепочке. Это удобный механизм для фильтрации http-запросов.
 Посредник может пропустить запрос или в какой-то момент перенаправить пользователя на страницу регистрации.

 Для создания посредника можно воспользоваться командой
 php artisan make:middleware AnyName.
 Она создаст класс AnyName в папке app/Http/Middleware.

 Для использования посредника его необходимо добавить в определенное свойство класса
 App\Http\Kernel.
 ● middleware — свойство содержит глобальные посредники. Они запускаются при каждом
 запросе к вашему приложению.
 ● middlewareGroups — свойство содержит наборы посредников для групп маршрутов.
 ● routeMiddleware — свойство содержит посредники, которые могут быть назначены группам
 или использоваться самостоятельно.
 ● middlewarePriority — свойство определяет порядок выполнения посредников

К примеру, если название класса будет добавлено как элемент массива web свойства middlewareGroups,
то он будет выполняться для всех маршрутов, указанных в роутах файла
web.php.

Если созданный класс посредника должен применяться только к определенному классу
контроллера или маршруту, его следует указать в свойстве
routeMiddleware в качестве значения массива,
а в качестве ключа — придумать имя, по которому данный посредник будет вызываться.

Указание вызова самостоятельного посредника может выполняться или в самом классе контроллера,
в методе конструктора или в описании маршрута.

Сессии в Laravel
Присмотримся к классу App\Http\Kernel, а именно к свойству middlewareGroups. Одним из
классов-посредников, используемых при выполнении маршрутов web.php, является класс
\Illuminate\Session\Middleware\StartSession.

Для настроек работы с сессией используется файл session.php в папке config. Данный файл
возвращает массив, в значениях которого указываются параметры работы сессии. В основном все
значения вычисляются проверкой существования их в файле конфигурации приложения (.env), и в
случае отсутствия подставляется значение по умолчанию. Это вычисление происходит благодаря
хелперу env().

Наиболее популярные варианты установки данных в сессию, их получения и очистки:
Первый — с помощью фасада Illuminate\Support\Facades\Session,
второй — с помощью хелпера session.
Этот фасад и хелпер имеют методы:
get('key') - получить данные по ключу, ключи бывают влооженными ('key1.key2')
put(['key'=>values]) - записать данные в сессию
all() - получить все данные, хранящиеся в сессии
flash()  - очищает все данные, находящиеся в сессии.

В случае с фасадом эти методы являются статичными, а с хелпером — динамическими,
но работают одинаково.



Если в конструктор контроллера добавить
$this->middleware('auth');
то маршрут этого контроллера будет доступен только после аутентификации.
pubkic function __construct()
{
    pubkic function __construct();
}
Чтобы не повторять эту строку во всех контроллерах

За редирект неаутентифицированного пользователя на домашнюю страницу
отвечает свойство $redirectTo в app/Http/Controllers/Auth/LoginController.php:
 protected $redirectTo = RouteServiceProvider::HOME;

Новый пользователь создаётся в app/Http/Controllers/Auth/RegisterController.php:
    protected function create(array $data)
    {
        return User::create([
            'name' => $data['name'],
            'email' => $data['email'],
            'password' => Hash::make($data['password']),
        ]);
    }

Посредники, которые обрабатывают любой HTTP-запрос указываются
в protected $middleware app/Http/Kernel.php

в массиве protected $middlewareGroups раздельно указываются посредники для групп маршрутов:
web и api

в protected $routeMiddleware можно добавлять посредники,
которые выборочно можно использовать в тех роутах, где они потребуются,
а также задавать им короткие псевдонимы.

В любую группу можно добавлять нужные посредники, но лучше это делать в routeMiddleware,
чтобы не снижать производительность приложения.

->Request->MiddleWare->Response

Метод-обработчик класса-посредника в качестве параметра принимает следующий посредник,
и возвращает его, передав следующему посреднику результаты своей работы в качестве аргументов.
И так до самого контроллера данного роута.
Посредник не обязательно должен изменять полученные им данные.
В методе-обработчике должно быть предусмотрено условие выхода,
если что-то пойдёт не так, как планировалось,
а также редирект на нужную страницу,

Например,'auth' => \App\Http\Middleware\Authenticate::class не изменяет Request.
а только проверяет, залогинен ли пользователь.
Если нет - то перенаправляет его на страницу Login.

Чтобы ограничить доступ к опредедённым страницам залогиненным (аутентифицированным),
но не авторизованным (не имеющим нужных прав) пользователям
будет правильно использовать middleware в маршрутах (~/routes):
Route::name('name')->middleware('mwn'), где mwn имя посредника или группы посредников.

Маршруты для регистрации и авторизации генерируются в ~/routes.web.php строкой
Auth::routes();
Если, например, маршрут для регистрации пользователей не требуетс,
можно создать свой роут аутентификации вручную.

//автоматически генерирует все запросы, необходимые для работы с аутентификацией, в том числе для сброса пароля
Auth::routes();
//Если маршруты для сброса пароля не нужны, можно создать остальные вручную
/*
Route::get('login', [\App\Http\Controllers\Auth\LoginController::class, 'showLoginForm'])->name('login');
Route::post('login', [\App\Http\Controllers\Auth\LoginController::class, 'login']);
Route::get('logout', [\App\Http\Controllers\Auth\LoginController::class, 'logout'])->name('logout');
*/

В Laravel не требуется стартовать сессию вручную. Для этго испоьзуется посредник.
Работать с сессиями можно через фасад или через хэлпер
session().

В посредниках можно выполнять валидацию, но нежелательно этого делать.

Фасад Auth позволяет получать объект текущего пользователя и далее использовать AR:
Auth::user()->name;

Для проверки авторизации пользователя в шаблонах можно использовать
Auth::check()
или
Auth::id() - проверить id авторизованного пользователя

Директивы аутентификации
Директивы @auth и @guest можно использовать для быстрого определения, аутентифицирован ли текущий пользователь или
является гостем:
@auth
    // The user is authenticated...
@endauth
@guest
    // The user is not authenticated...
@endguest

При необходимости вы можете указать защиту аутентификации, которую следует проверять при использовании директив @authи :@guest
@auth('admin')
    // The user is authenticated...
@endauth
@guest('admin')
    // The user is not authenticated...
@endguest


Директива Laravel Blade @error

Вы можете использовать директиву @error Blade, чтобы быстро определить,
существуют ли сообщения об ошибках проверки для данного атрибута.
Внутри @error директивы вы можете использовать переменную $message,
в которую помещается текст ошибки,
чтобы отобразить сообщение об ошибке:

<!-- /resources/views/post/create.blade.php -->
<label for="title">Post Title</label>
<input id="title"
    type="text"
    name="title"
    class="@error('title') is-invalid @enderror">
@error('title')
    <div class="alert alert-danger">{{ $message }}</div>
@enderror

Если вы используете именованные пакеты ошибок,
вы можете передать имя пакета ошибок в качестве второго аргумента @error директиве:
<input ... class="@error('title', 'post') is-invalid @enderror">


@error('name')
       <span class="invalid-feedback" role="alert">
       <strong>{{ $message }}</strong>
       </span>
@enderror

работает аналогично

@if($errors->has('name'))
    @foreach($errors->get('name') as $error
     {{ $error }}
    @endforeach
@endif

Пример правила валидации пароля:
'email'=>'required|email|unique:users,email,'.Auth::id(),
обязательное, в формате email,
unique:users,email - должно быть уникальным значением для столбца email таблицы users
.Auth::id() - для исключения из ограничения email текущего авторизованного пользователя.

Получить объект теущего аутентифицированного пользователя
       $user = Auth::user();
 Фасад Auth в данном методе гарантированно вернёт объект пользователя,
  т.к. данный метод будет вызван из посредника, который проверил аутентификацию.
  Испоьзуя AR можно получать любые поля объекта User из БД
  $userName = Auth::user()->name;

Получить информацию о пользователе с помощью помошника/хелпера auth():
$user = auth()->user();

Illuminate\Support\Facades\Hash
Hash::check($hash1, $hash2) - сверить hash.
//сверить hash старого и нового паролей.
   if (Hash::check($request->post('password'), $user->password));

   ->withErrors()
   После определения того, не прошла ли проверка запроса, вы можете использовать этот withErrors метод для передачи
   сообщений об ошибках в сеанс. При использовании этого метода $errorsпеременная будет автоматически передана вашим
   представлениям после перенаправления, что позволит вам легко отобразить их обратно пользователю. Метод withErrors
   принимает валидатор, MessageBag или PHP array.
        $validator = Validator::make($request->all(), [
            'title' => 'required|unique:posts|max:255',
            'body' => 'required',
        ]);
        if ($validator->fails()) {
            return redirect('post/create')
                        ->withErrors($validator)
                        ->withInput();
        }


Метод ->save() возвращает Boolean

Создать кастомный (пользовательский) посредник (middleware)
$ sail artisan make:middleware CheckIsAdmin
   INFO  Middleware [app/Http/Middleware/CheckIsAdmin.php] created successfully.

Добавим созданный middleware для маршрутов зоны admin.
Последовательность выполнения посредников важна,
если сначала проверять наличие значения true в поле is_admin у незалогиненного пользователя,
а потом запускать ->middleware('auth'), то логика работы будет нарушена (admin не сможет выполнять свои функции).

Зарегистрируем созданный пользовательский middleware CheckIsAdmin
в методе $routeMiddleware класса app/Http/Kernel.php под псевдонимом is_admin.
Посредники из метода $routeMiddleware необходимо задействовать вручную для выбранных маршрутов.
Задействуем ->middleware('is_admin') для маршрутов зоны admin.




Скрыть в меню зону админа для неавторизованных пользователей.
Залогиненные неадмины тоже не должны её видеть.
Образец взять в шаблонах страниц в папке auth, а токже layout.
Нужно использовать директиву @guest.

Вёрстка prifile.blade.php - 1:04

Практическое задание
Нужно выполнить посев Users - выполнено.
$ sail artisan db:seed --class=UsersSeeder

1. Реализовать механизм регистрации обычных пользователей - выполнено.
2. В админке агрегатора реализовать редактирование профилей пользователей с возможностью
их перевода в администраторы.
Сделать кнопку toggle, которая позволит давать/забирать права администратора пользователям.
Красная кнопка - админ, зелёная - юзер.
Исключить текущего пользователя из списка редактируемых, чтобы случайно не лишить себя прав администратора.
3. * Перенести валидации данных в посредники (дополнительное задание) - выполнять не требуется.

Сделать кнопку Профиль доступной любому пользователю после аутентификации в выпадающем меню в правом углу.

Задействовать отношения.


Урок 9. События в Laravel. Провайдеры. Работа со сторонними API

Cоздаём контроллер и маршрут для парсинга новостей.
Он будет только выполнять действие (парсинг), без вывода страницы,
поэтому создавать отдельный шаблон для него не нужно.
 sail artisan make:controller Admin/ParserController

Сначала установим пакет парсера, выполнив команду composer require "orchestra/parser=^4.0"
После успешного скачивания пакета разместим его в списке провайдеров и добавим новый фасад в
файле app.php.

Подключим orchestra/parser
https://packagist.org/packages/orchestra/parser

sail composer require "orchestra/parser"

//регистрируем Parser в провайдерах config/app.php
'providers'=>[...Orchestra\Parser\XmlServiceProvider::class,]
//создаём псевдоним Parser в алиасах config/app.php
'aliases' => [...'XmlParser' => Orchestra\Parser\Xml\Facade::class,]

Чтобы использовать Parser его нужно подключить в соответствующем классе
use Orchestra\Parser\Xml\Facade as XmlParser;
_____________________________________________
$xml = XmlParser::load('path/to/above.xml');

//Для разбора полей источника данных можно вывести на экран содержимое $xml

● через точку указываются узлы xml-документа, при этом игнорируется корневой;
● если данные в xml-документе повторяются, то их указывают в квадратных скобках. Эти
данные будут возвращены в виде массива.

$user = $xml->parse([
    'id' => ['uses' => 'user.id'],
    'email' => ['uses' => 'user.email'],
//через :: указывается наименование извлекаемого атрибута
    'followers' => ['uses' => 'user::followers'],
//извлечь повторяющиеся данные в виде массива
    'news'=>['uses' =>'channel.item[title,category,description,enclosure::url]']
]);
_____________________________________________
https://www.kommersant.ru/RSS/news.xml

https://rssexport.rbc.ru/rbcnews/news/30/full.rss
https://news.ru/rss/
https://lenta.ru/rss

1:04 Использовать не insert() и update(), а firstOrCreate()
Перед добавлением новости в БД нужно убедиться, что соответствующая ей категория существует (firstOrCreate()).
В случае отсутствия нужной категории - создать её.
firstOrCreate() нужно использовать вместо insert() -это также позволит организовать добавление только свежих новостей
при повторном нажатии на кнопку Parse.
Для этого нужно анализировать время добавления новости (свойство pubDate в RSS Lenta.ru).

//Структура XML Lenta.ru
Orchestra\Parser\Xml\Document {#1471 ▼ // app/Http/Controllers/Admin/ParserController.php:14
  #content: SimpleXMLElement {#1470 ▶
    +"@attributes": array:1 [▶
      "version" => "2.0"
    ]
    +"channel": SimpleXMLElement {#1503 ▶
      +"language": "ru"
      +"title": "Lenta.ru : Новости"
      +"description": "Новости, статьи, фотографии, видео. Семь дней в неделю, 24 часа в сутки."
      +"link": "https://lenta.ru"
      +"image": SimpleXMLElement {#1500 ▶
        +"url": "https://lenta.ru/images/small_logo.png"
        +"title": "Lenta.ru"
        +"link": "https://lenta.ru"
        +"width": "134"
        +"height": "22"
      }
      +"item": array:200 [▶
        0 => SimpleXMLElement {#1501 ▶
          +"guid": "https://lenta.ru/news/2022/12/04/role/"
          +"author": "Варвара Кошечкина"
          +"title": "Раскрыта роль западных спецслужб в готовящейся Киевом провокации с аммиаком"
          +"link": "https://lenta.ru/news/2022/12/04/role/"
          +"description": SimpleXMLElement {#1694}
          +"pubDate": "Sun, 04 Dec 2022 09:59:00 +0300"
          +"enclosure": SimpleXMLElement {#1695 ▶
            +"@attributes": array:3 [▶
              "url" => "https://icdn.lenta.ru/images/2022/12/04/10/20221204100018624/pic_e99bd3f53bd2e4d56897dd0c741a1897.jpg"
              "type" => "image/jpeg"
              "length" => "39647"
            ]
          }
          +"category": "Бывший СССР"
        }

8 ТРЮКОВ С МЕТКАМИ ВРЕМЕНИ LARAVEL
https://www.whitelabeldevelopers.ru/articles/8-tryukov-s-metkami-vremeni-laravel

Парсинг дат
Для работы с датами в Laravel присутствует библиотека Carbon
'publication_date'=>Carbon::parse($item['pubDate']),

 $newsLatestTime = Carbon::createFromTimeString($latestPublicationTime); - создать время из строки

Сравнение времени Carbon (существует много методов)Ж
$newsPublicationTime->gt($newsLatestTime); - больше >


Для авторизации с использоватнием OAUTH2 в Laravel входит специальный пакет Socialite для подключения с помощью некоторых соцсетей.
Для остальных соцсетей можно установить отдельный компонент и добавить свои настройки, указанные на сайте
https://socialiteproviders.com/
Например, VKontakte
sail composer require socialiteproviders/vkontakte

Добавить конфигурацию в config/services.php
//берутся из .env, поэтому их нужно туда добавить
'vkontakte' => [
  'client_id' => env('VKONTAKTE_CLIENT_ID'),
  'client_secret' => env('VKONTAKTE_CLIENT_SECRET'),
  'redirect' => env('VKONTAKTE_REDIRECT_URI')           //Доверенный redirect URI в настр. прил. VK
],
указанные выше параметры нужно взять на сайте VK и внести в .env
https://dev.vk.com/


#Добавить прослушиватель событий поставщика
Настройте прослушиватель пакета для прослушивания SocialiteWasCalled событий.
Добавьте событие в свой listen[]массив в app/Providers/EventServiceProvider.
См. Руководство по базовой установке (открывает новое окно)для получения подробных инструкций.
В свойстве $listen перечисляются классы, которые подписываются на события в других классах.
В нашем случае класс SocialiteWasCalled подписывается на события класса VKontakteExtendSocialite,
чтобы при вызове метода обработчика @handle класса VKontakteExtendSocialite автоматически перенаправить запрос на сервис
 vk.com, а затем отследить получение ответа.
protected $listen = [
    \SocialiteProviders\Manager\SocialiteWasCalled::class => [
        // ... other Socialite providers
        \SocialiteProviders\VKontakte\VKontakteExtendSocialite::class.'@handle',
    ],
];
#Применение
Теперь вы сможете использовать провайдера, как если бы вы регулярно использовали Socialite (при условии, что у вас установлен фасад):
return Socialite::driver('vkontakte')->redirect();

Последовательность добавления авторизации через VK
1. Создаём приложение на сайте VK
2. Сохраняем настройки приложения с сайта VK в .env
3. Создаём контроллер, например, sail artisan make:controller SocialiteLoginController
4. Добавляем в метод-обработчик запроса на авторизацию SocialiteLoginController строку
 return Socialite::driver('vkontakte')->redirect();
 согласно инструкции
https://laravel.com/docs/9.x/socialite#authentication
5. Регистрируем маршруты, которыми смогут пользоваться только незарегистрированные пользователи - гости. Для этого используем middleware guest.

Route::get('/auth/redirect/vk', [SocialiteLoginController::class, 'vkLogin'])->name('vkLogin')->middleware('guest');
Route::get('/auth/callback/vk',  [SocialiteLoginController::class, 'vkResponse'])->name('vkResponse')->middleware('guest');

Для аутентификации пользователей с помощью провайдера OAuth вам понадобятся два маршрута: один для перенаправления пользователя к провайдеру OAuth, а другой — для получения обратного вызова от провайдера после аутентификации.
Метод vkLogin выполняет redirect, предоставленный Socialite фасадом, заботится о перенаправлении пользователя к провайдеру OAuth,
 return Socialite::driver('vkontakte')->redirect();

 в то время как vkResponse метод проверяет входящий запрос и получает информацию о пользователе от провайдера после того, как он одобрил запрос аутентификации.
$user = Socialite::driver('github')->user();
     // $user->token
6. После получения данных о пользователя от сервера соцсети нужно на базе них создать пользователя, например:
$user = User::updateOrCreate([
        'github_id' => $githubUser->id,
    ], [
        'name' => $githubUser->name,
        'email' => $githubUser->email,
        'github_token' => $githubUser->token,
        'github_refresh_token' => $githubUser->refreshToken,
    ]);

    Auth::login($user);
 А затем выполнить редирект на нужну страницу.

 Ещё примеры:
 Создание приложения Vk (client-а)
https://habr.com/ru/post/684196/

Т.к. у пользователя могут быть аккаунты в нескольких соцсетях, через которые он захочет поочерёдно авторизовываться, то
в таблицу users БД необходимо добавить новый столбец -
sail artisan make:migration alter_table_users_add_column_authorization_social_network

После этого нужно добавить названия созданных столбцов в свойство fillable класса User.
Т.к. от различных соцсетей могут приходить в различных форматах,
применим паттерн Repository.
Создадим класс UserRepository.
use App\Models\User;
//объекты, приходящие от соцсети, являются экземплярами данного класса
use Laravel\Socialite\Contracts\User as UserOAuth;
По полученному от соцсети id и названию соцсети ищем в БД пользователя.
Если он существует, то возвращаем его.
Если нет - создаём новый экземпляр класса User и заполняем его данными, полученными от соцсети,
сохраняем его в БД и возвращаем.

Задействуем UserRepository в SocialiteLoginController

Чтобы авторизация через соцсеть заработала, нужно убрать required с input для ввода пароля.

В фасаде Auth есть метод login. Используем его в SocialiteLoginController, передав объект пользователя.



Домашнее задание:
В методе, создающем нового пользователя на основании данных, полученных от соцсети,
настроить валидацию поля email.
Избавиться от дублирования роутов (использовать маршрут с параметром) и методов для авторизации чере соцсети 2:10.

1. Настроить авторизацию чере GitHub
2. Сделать парсинг новостей с последующим редиректом на список



Урок 10. Добавление HTML-редактора. Хранение файлов. Очереди в Laravel

Чтобы "тяжёлые" задачи не приводили к "зависанию" сервера в Laravel применяется механизм очередей.
"Тяжёлые" задачи принято выполнять в отдельном потоке в фоне,
к тому же, эти задачи можно выполнять параллельно в нескольких потоках.

Чтобы сгенерировать такое новое задание, используется команда
sail artisan make:job NewsParsing
//создан app/Jobs/NewsParsing.php

Эта команда поместит новый класс задания в каталог app/Jobs вашего приложения.
Если этот каталог не существует в вашем приложении, то Laravel предварительно создаст его:

php artisan make:job ProcessPodcast
Сгенерированный класс будет реализовывать интерфейс Illuminate\Contracts\Queue\ShouldQueue, указывая Laravel, что задание должно быть поставлено в очередь для асинхронного выполнения.

Паттерн:
для рассылок принято создавать приватное поле $links в Job,
которое будет заполнено данными через конструктор.

В метод Job->handle() нужно передать сервис для внедрения зависимости.
В качестве аргумента в сервис нужно передать $this->link.

Laravel будет вызывать Job->handle() самостоятельно.
Это так называемый Worker - рабочий - который делает одну задачу.
В нашем случе рабочий парсит одну ссылку.

Чтобы задействовать созданный Worker нужно в контроллере вместо прямого обращения к соответствующему сервису будем
регистрировать задачи с помощью статического метода dispatch($params),
который регистрирует задачу, например:
NewsParsing::dispatch($link);

https://laravel.com/docs/9.x/queues#main-content
Для асинхронного выполнения задач Worker нужно в .env изменить настройки очереди (QUEUE_CONNECTION) с синхрнонного на
database или REDIS (лучше):
QUEUE_CONNECTION=REDIS

Чтобы использовать QUEUE_CONNECTION=database предварительно нужно создать таблицу в БД:

Для этого нужно выполнить команды:
sail artisan queue:table
sail artisan migrate

После этого Workers будут не выполняться незамедлительно, а помещаться в таблицу БД.
Чтобы запустить из выполнение нужно выполнить команду:
sail artisan queue:work
Это приведёт к последовательному выполнению всех задач, хранящихся в таблице jobs нашей БД.

Параллельно можно запускать несколько Workers в нескольких терминалах, например :).
Это ускорит процесс парсинга.

Ctrl+c - прервать работу Worker

В Linux будет работать команда
sail artisan queue:work &       - запуск Worker в фоновом режиме

sail artisan queue:restart      -остановка работы Workers, работающих в фоновом режиме


Redis - аналог Memcached - БД, располагающаяся в оперативной памяти.
Чтобы они работали в OpenServer нужно активировать соответствующие настройки (там же, где и настройки MySQL). Для Redis
в OpenServer существует RedisAdmin, наподобие PhpMyAdmin (находится там же).
Чтобы локальный PHP мог взаимодействовать с Redis, нужно в его файле настроек раскомментировать расширение redis:
extension = redis

Чтобы задействовать Redis нужно установить соответствующй пакет:
php composer require predis/predis
и переключить настрйку сохранения задач для Workers в redis в .env
QUEUE_CONNECTION=redis
в ~config/app.php добавить псевдоним ('alias'):
        'Redis'=>\Illuminate\Support\Facades\Redis::class,

Существует внешний пакет Laravel для метрик очередей в Redis - Horizon
 Horizon предоставляет удобный графический интерфейс для работы с Redis через админ-панель сайта.
 С помощью Horizon удобно отслеживать не работающие источники новостей, например.

https://laravel.com/docs/9.x/horizon#installation
Установка Horizon:
composer require laravel/horizon
После установки Horizon опубликуйте его ресурсы с помощью
horizon:install команды Artisan:
php artisan horizon:install
Запуск обработчиков Horizon (другие обработчики (Workers) теперь запускать не надо)
sail artisan horizon

Руководство: Как заставить Redis и Horizon работать с Sail
Запись для потомков, так как этой информации нет в одном месте в документации и может потребоваться некоторое время, чтобы понять, почему Redis и Horizon не работают с Sail.

Предполагаем, что у вас есть установка контейнера Sail+redis по умолчанию:

во-первых, нет необходимости устанавливать predis/predis. Я вижу, что это используется в качестве обходного пути во многих ответах, когда на самом деле вы делаете в обход паруса.
Итак, чтобы все работало с использованием собственно Sail:

перейдите config/app.php и раскомментируйте псевдоним Redis, чтобы вы не получили «класс не найден»
в .envдобавьте REDIS_HOST=redisтак, чтобы он указывал на контейнер Sail redis
в .env, добавить/изменить наQUEUE_CONNECTION=redis
обновить кешphp artisan config:cache
запустить сервер горизонтphp artisan horizon
теперь посетите localhost.test/horizon, и вы должны увидеть панель инструментов Horizon, а в поле «Статус» должно быть указано «Активно».
Вы можете выполнить быстрый тест кода, например, сделать это
 Redis::set('name', 'Taylor');в Tinker,
  а затем вы даже можете подключиться к базе данных Redis, используя что-то вроде TablePlus, и увидите данные, сохраненные в базе данных Redis.




 Полезные дополнительные пакеты Laravel:
https://github.com/chiraggude/awesome-laravel

ДЗ - получить список ресурсов новостей из модели.

sail artisan make:model NewsSource -m

Добавляю в созданной миграции в таблицу необходимое дополнительное поле:
$table->string('link', 75);

sail artisan migrate

В модель NewsSource добавляю свойство
protected $fillable = ['link'];

Создаю ресурсный контроллер:
sail artisan make:controller Admin/NewsSourceController -r

В маршруты администратора web.php добавляю
 Route::resource('news_source', AdminNewsSourceController::class)->except(['show']);

Создаю папку
resources/views/admin/news_sources
и помещаю в неё шаблоны для работы с источниками новостей.

Добавляю пункт в меню администратора.

Заполняю методы CRUD в NewsSourceController.php

        //Получаю все строки из таблицы, отсортированные по дате изменения в обратном порядке
        $newsSources = NewsSource::orderBy('updated_at', 'desc')->get();

При валидации данных в реквесте (Request, request) для исключения ограничения на уникальность (unique) полей текущего
объекта данных нужно явно передать значение id с помощью скрытого input:
<input type="hidden" name="id" value="{{ $newsSource->id }}">

Тогда правило валидации может выглядеть так:
 'title'=>['required', 'min:3', 'max:5', Rule::unique('news_sources')->ignore($this->id)],
или так



