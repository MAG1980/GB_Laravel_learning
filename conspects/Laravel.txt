При внесении изменений в файл .env под Windows к нему применяется кодировка DOS и возникают ошибки
./.env: line 6: $'\r': command not found
Преобразовать кодировку обратно можно с помощью команды:
$ dos2unix .env .env
dos2unix: converting file .env to Unix format...

Возникала ошибка
SQLSTATE[HY000] [1044] Access denied for user 'sail'@'%' to database 'example_app' (SQL: select * from information_schema.tables where table_schema = example_app and table_name = migrations and table_type = 'BASE TABLE')

Решил с помощью этой инструкции:
https://gist.github.com/jjsquady/e12ce89c9029d520ce08f60a9ff8f304
Выполнил команды:
docker-compose exec mysql bash

bash-4.4# mysql -u root -p
Enter password:
password (символы не отображаются)

mysql> mysql -u root -p

mysql> GRANT ALL PRIVILEGES ON *.* TO 'sail'@'%';
Query OK, 0 rows affected (0.01 sec)

mysql> FLUSH PRIVILEGES;
Query OK, 0 rows affected (0.01 sec)

mysql> EXIT;


Советы по работе с Docker:

если идти на 127.0.0.1, то надо указывать внешний  порт проброса.
если идти на  172.17.88.101  то надо идти на внутренний.

то есть проброс

ports : 33060:3306
первый внешний, второй внутренний.

А  еще, есть команда docker inspect,
которая покажет всю инфу по контейнеру.



Чтобы удалить пакет из проекта нужно использовать откат в Composer:
удалить строчку пакета в json и папку vendor и сделать install

Чтобы подключиться к удалённому репозиторию, пришлось создать ветку dev.
$ git pull выдавала ошибку.
--------------------------------------------------------------
$ git pull
У текущей ветки нет информации об отслеживании.
Пожалуйста, укажите с какой веткой вы хотите слить изменения.
Для дополнительной информации, смотрите git-pull(1).

    git pull <внешний-репозиторий> <ветка>

Если вы хотите указать информацию о отслеживаемой ветке, выполните:

    git branch --set-upstream-to=origin/<ветка> dev
----------------------------------------------------------
Сработала команда, где  origin/dev — название «удалённой» ветки,
а dev — название локальной.

$ git branch --set-upstream-to=origin/dev dev
Ветка «dev» отслеживает внешнюю ветку «dev» из «origin».
$ git pull
fatal: отказ слияния несвязанных историй изменений
$ git fetch
$ git reset --hard origin/dev
Указатель HEAD сейчас на коммите f87ae1f Начало практики к уроку №2. Создан HomeController.
alexey@pc34:~/PhpstormProjects/Laravel-learning$ git pull

Проблема подключения к внешнему репозиторию решена.


wsl - запустить Linux в Windows

Чтобы создать новое приложение Laravel в каталоге с именем «example-app», вы можете запустить следующую команду в своем терминале:
curl -s https://laravel.build/example-app | bash - установка Laravel Sail

./vendor/bin/sail up - запустить Sail

Чтобы подключиться к виртуальной Linux из PHPStorm нужно в его терминале ввести команду wsl.

alias sail="bash ./vendor/bin/sail" - создание псевдонима для команды запуска проекта (нужно создавать и запускать из папки проекта).

С использованием псевдонима:
sail up -d - с отсоединением консоли

Урок 2. Роутинг. Использование контроллеров

В старых версиях PHPStorm может потребоватья настроить IDEHelper (ServiceProvider).
Сейчас IDE берёт список методов из PHPDoc класса.

Маршруты хранятся в папке routes.
Маршруты SSR хранятся в файле web.php
Маршруты SPA хранятся в файле api.php

Маршруты задаются с помощью статических методов класса Route, который наследуется от фасада.
Laravel при первом обращении к классу Router создаёт в контейнере его экземпляр.
Реализация паттерна Facade позволяет скрыть сложную релализацию за простым фасадом.

При создании маршрута в первую очередь указывается его HTTP-метод.
Route::get (post), который первым параметром принимает адрес, а вторым - коллбек-функцию-обработчик,
которая возвращает нужный хэлпек view или сразу данные (HTML?).

Route::match(['post', 'get']) - статический метод класса Route,
позволяющий обрабатывать все HTTP-методы, указанные в массиве.

Представления - view хранятся в ~/resources/views


Route::get('/info', function () {
    return view('info');
});
эта запись аналогична следующей:
Route::view('/info', 'info');
});


Вместо view можно передать HTML-разметку:
Route::view('/test', 'test');

Передать данные в представление ('news' - переменная, $news - значение)
        view('news.news')->with ('news', $news);

Первый параметр - alias,
второй параметр - название шаблона,
третьим параметром можно передать ассоциативный массив со значениями переменных шаблона.
В маршрут можно передать значения переменных в виде массива, который передаётся третим параметром:
Route::view('/', 'index', [
	'name' => 'Admin'
]);


В этом варианте не используются модель и контроллер.
Это можно делать, если передача данных в шаблон не требуется.

Более правильный вариант - с использованием контроллера:
Route::get('/', [HomeController::class, index]);
HomeController - класс, который наследуется от Controller и содержит метод-обработчик (index).

Пример маршрута с параметром:
Route::get('/{slug}', [HomeController::class, index]);

значение slug будет доступно в параметре ($slug) метода index контроллера HomeController,
при этом важно не забыть её принять: public function index($slug)

Route::get('/{category}/buy/{slug}', [HomeController::class, index]);
Если параметров маршрута несколько, то их нужно перечислить через запятую: public function index($category, $slug)

StyleGuide:
Важно -
при создании маршрутов, псевдонимов маршрутов, методов-обработчиков маршрутов в контроллерах, представлений
следует придерживаться одинаковых именований:
Route::get('/create', [AdminNewsController::class, 'create'])->name('create');



Чтобы создать HomeController, используя средства Laravel, нужно ввести команду
$ sail artisan make:controller HomeController
Эта команда будет вызывать ошибку, если в приложении уже есть строка,
в которой происходит обращение к несуществующему контроллеру (её нужно предварительно закомментировать),
т.к. перед выполнением команды artisan выполняет код приложения.


sail artisan help make:controller

Artisan - интерфейс командной строки, который в Laravel используется для ввода команд,
ускоряющих разработку приложения (для автоматической генерации кода).
Дли использования artisan нужно выполнить команду: $ php artisan
При использовании Laravel Sail: $sail artisan

Чтобы получить подробную информацию по команде, следует указать после artisan слово help и имя нужной команды.
Например:
$ sail artisan help make:controller




Для перенаправления на другую страницу используется метод redirect:
Route::redirect('маршрут', 'маршрут, на который осуществляется перенаправление', код ответа сервера);
Route::redirect('redir', '/', 301);

Кастомную страницу 404 можно сделать с помощью метода fallback:
Route::fallback(function (){
	return view('beauty_404');
});

!!! Маршрут страницы 404 должен располагаться в самом низу списка маршрутов.

Если из БД вместо данных получен NULL, то в контроллере следует сделать редирект на "404" .
if(is_null($data)){
	return redirect()->action([HomeController::class, 'index']);
}

$ php artisan route:list - выводит список зарегистрированных маршрутов
$ php artisan route:list --except-path=api,_ignition,sanctum - вывести только пользовательские маршруты

$ php artisan route:cache - кешировать маршруты.
После этого Laravel берёт информацию о маршрутах не из папки routes, а из кеша.
Кеширование маршрутов обязательно нужно делать на рабочем сервере (в ProductionMode), т.к. сборка маршрутов занимает много времени.
$ php artisan route:clear

!!! При использовании Laravel Sail вместо php нужно писать sail
sail artisan route:list

Если не использовать сырую разметку (вывод через {!! .... !!} ) и использовать валидаторы (либо в контроллерах, либо FormRequest, то ларка вполне безопасна)))
при ошибке валидации автоматом же в old значения попадут и будет редирект обратно в форму

Помещать функционал контроллера в роутер - плохая идея.

В Laravel контроллеры хранятся в папке ~/api/Http/Controllers, в том числе базовый класс Controller.

Хэлпер dump используется для отладки.
Он позволяет вывести информацию о значении переменной без остановки вывода.

Хэлпер dd выводит информацию о значении переменной с остановкой вывода.

Дополнительное ДЗ от преподавателя:
1:40 -

Контроллеры принято разносить по разным папкам.
Например, контролеры для путей, доступны только админу будем хранить в папке Admin.

Route::get('/admin', [
	'uses' => 'Admin\IndexController@index' — после @ указано название метода
]);


Чтобы устранить ошибки после подключения репозитория к Ubuntu пришлось стать владельце папки проекта с помощью команды:
sudo chmod o+w ./Laravel-learning/ -R



$ sail artisan tinker — позволяет вывести значение какого-либо хэлпера:

root@pc34:/home/alexey/PhpstormProjects/Laravel-learning# sail artisan tinker
Psy Shell v0.11.8 (PHP 8.1.11 — cli) by Justin Hileman
>>> view('index')
=> Illuminate\View\View {#3673}

>>> route('home')
Symfony\Component\Routing\Exception\RouteNotFoundException with message 'Route [home] not defined.'
>>> route('404')
=> "http://localhost/404"

Иногда вам может понадобиться запустить сеанс Bash в контейнере вашего приложения.
Вы можете использовать эту shell команду для подключения к контейнеру вашего приложения,
что позволит вам проверять его файлы и установленные службы, а также выполнять произвольные команды оболочки внутри контейнера:

sail shell
 
sail root-shell

Чтобы передать в шаблон псевдоним маршрута необходимо использовать хэлпер route()
route('имя маршрута', 'параметр запроса (необяз.)')

<a href="<?=route('news.one', $item['id']) ?>"><?= $item['title'] ?></a><br>


Чтобы выделить текущий пункт меню можно использовать хэлпер named('имя маршрута')
/**
 * Handle an incoming request.
 *
 * @param  \Illuminate\Http\Request  $request
 * @param  \Closure  $next
 * @return mixed
 */
public function handle($request, Closure $next)
{
    if ($request->route()->named('profile')) {
        //
    }
 
    return $next($request);
}
или

Route::is('имя маршрута'):boolean


Для группировки маршрутов по имени используется хэлпер Route::name('имя маршрута'), а для группировки по префиксу Route::prefix('префикс')

StyleGuide: Route::name('имя маршрута') - имя маршрута должно быть таким же, как имя шаблона или имя метода контроллера.

Для группировки маршрутов используется хэлпер group(callback):

Route::name('admin.')
    ->prefix('admin')
    ->group(function () {
        Route::get('/', [IndexController::class, 'index'])->name('index');
        Route::get('/test1', [IndexController::class, 'test1'])->name('test1');
        Route::get('/test2', [IndexController::class, 'test2'])->name('test2');

    });

Маршруты можно группировать и по namespace: Route::namespace('namespace')

Для перенаправления на нужный маршрут в случае отстутствия нужной страницы (данных)
использутеся хэлпер ->missing(function(
	{
		return view('product.not_found');
	}));


Для SEO важно в маршрутах использовать слова:
/news/category/1 	- плохо
/news/category/sport	- хорошо

Str::slug - Метод генерирует дружественный URL-адрес "slug" из заданной строки:
use Illuminate\Support\Str;
$slug = Str::slug('Laravel 5 Framework', '-');


Советы к ДЗ:
Добавить в массивы новостей и категорий ключи ID, которые совпадают с id новости или категории, чтобы не искать новость перебором.

https://www.youtube.com/watch?v=8X77WSGg29c


Laravel Livewire используется для создания динамических интерфейсов без использования JS, Vue или React.
Laravel Livewire - спорная ("игрушечная" технология),
т.к., например, во время ввода данных в input, на сервер посылается огромное количество запросов,
что приводит к перегрузке сервера.

Правильнее будет использование JavaScript-фреймворка Alpine.js

Шаблонизатор даёт скорость, гибкость и безопасность.

Шаблонизатор Blade позволяет писать PHP-код внутри {{ }}, т.е. даже вызывать PHP-функции,
поэтому внутри {{ $varable }} перед именем переменной нужно ставить знак $.
JavaScript-код, содержащийся в переменной, выводимой в шаблон, будет экранирован.
Чтобы отключить экранирование Javascript нужно использовать {!! $variable !!}

Поскольку многие фреймворки JavaScript также используют «фигурные» скобки для обозначения того,
что данное выражение должно отображаться в браузере, вы можете использовать @символ,
чтобы сообщить механизму рендеринга Blade, что выражение должно оставаться нетронутым.
Например:

<h1>Laravel</h1>
Hello, @{{ name }}.

В этом примере @символ будет удален Blade;
тем не менее, {{ name }}выражение останется нетронутым движком Blade,
что позволит вам отображать его с помощью вашей инфраструктуры JavaScript.

Этот @символ также может использоваться для экранирования директив Blade:

{{-- Blade template --}}
@@if()
<!-- HTML output -->
@if()

Если вы отображаете переменные JavaScript в большей части своего шаблона,
вы можете обернуть HTML в @verbatimдирективу,
чтобы вам не нужно было префикс каждого оператора эха Blade @символом:

@verbatim
    <div class="container">
        Hello, {{ name }}.
    </div>
@endverbatim

Экранирование рендеринга атрибутов
Поскольку некоторые фреймворки JavaScript, такие как Alpine.js,
также используют атрибуты с префиксом двоеточия, вы можете использовать префикс с двойным двоеточием ( ::),
чтобы сообщить Blade, что атрибут не является выражением PHP. Например, для следующего компонента:

<x-button ::class="{ danger: isDeleting }">
    Submit
</x-button>

Следующий HTML будет отображаться Blade:

<button :class="{ danger: isDeleting }">
    Submit
</button>



Макеты с использованием наследования шаблонов

Директива @section, как следует из названия, определяет раздел содержимого,
а @yield директива используется для отображения содержимого данного раздела.

<!-- resources/views/layouts/app.blade.php -->

<html>
    <head>
        <title>App Name - @yield('title')</title>
    </head>
    <body>
        @section('sidebar')
            This is the master sidebar.
        @show
        <div class="container">
            @yield('content')
        </div>
    </body>
</html>

Расширение макета
При определении дочернего представления используйте @extends директиву Blade, чтобы указать, какой макет дочернее представление должно «наследовать».
Представления, расширяющие макет Blade, могут вставлять содержимое в разделы макета с помощью @section директив.
Помните, как видно из приведенного выше примера, содержимое этих разделов будет отображаться в макете с помощью @yield:

<!-- resources/views/child.blade.php -->

@extends('layouts.app')
@section('title', 'Page Title')
@section('sidebar')
    @parent
     <p>This is appended to the master sidebar.</p>
@endsection
@section('content')
    <p>This is my body content.</p>
@endsection

В этом примере sidebarраздел использует @parentдирективу для добавления (а не перезаписи) контента на боковую панель макета.
Директива @parentбудет заменена содержимым макета при отображении представления.


Для подключения Vue, React или Bootstrap к Laravel можно использовать пакет Laravel/UI
https://packagist.org/packages/laravel/ui#v4.0.2
с помощью команды:
composer require laravel/ui

Для установки пакета Laravel/UI в контейнер Docker (Laravel Sail)
нужно сначала запустить конетейнер командой sail up,
а затем выполнить команду

sail composer require laravel/ui

Далее следовать инструкции на сайте https://packagist.org/packages/laravel/ui#v4.0.2

Например, чтобы подключить Vue с Bootstrap и автоматическим созданием шаблонов форм авторизации, нужно выполнить команду:

sail artisan ui vue --auth

При этом автоматически будут созданы:

resources/views/layouts/app.blade.php
resources/js/components/ExampleComponent.vue
resources/js/app.js
resources/js/app.bootstrap.js
и т.п.


Вообще, чтобы выполнять любые команды внутри контейнера Docker,
в том числе и npm,
нужно обязательно вводить префикс ./vendor/bin/sail (или использовать алиас sail), например:

sail npm run dev - чтобы запустить live-server для разработки UI

sail npm run build - сборка Frontend (css и JS) для production



Для подключения ресурсов (стилей и JS) в шаблонах нужно использовать директиву @vite (образец - в app.blade.php, который сгенерировал laravel/ui):

 @vite(['resources/sass/app.scss', 'resources/js/app.js'])

где перечислены точки входа стилей и JS. Остальные стили должны подключаться в точке входа через директиву @import.
(В точке входа (файле resources/sass/app.scss) подключить свои стили с помощью директивы @import 'my-app.scss';)

При разработке SPA точку входа CSS лучше не использовать.
Вместо этого стили нужно импортировать в resources/js/app.js файле вашего приложения:

import './bootstrap';
import '../css/app.css';


Необходимо сообщить Vite о ваших ресурсах, импортировав статические ресурсы в точку входа приложения.
Например, если вы хотите обрабатывать и версионировать все изображения,
хранящиеся в , resources/imagesи все шрифты,
хранящиеся в resources/fonts,
вы должны добавить следующее в resources/js/app.jsточку входа вашего приложения:

import.meta.glob([
  '../images/**',
  '../fonts/**',
]);

Эти активы теперь будут обрабатываться Vite при запуске npm run build. Затем вы можете ссылаться на эти активы в шаблонах Blade, используя Vite::assetметод, который вернет версионный URL-адрес для данного актива:

<img src="{{ Vite::asset('resources/images/logo.png') }}">


Рендеринг на стороне сервера (SSR)
Плагин Laravel Vite упрощает настройку рендеринга на стороне сервера с помощью Vite. Для начала создайте точку входа SSR resources/js/ssr.jsи укажите точку входа, передав параметр конфигурации плагину Laravel:

import { defineConfig } from 'vite';
import laravel from 'laravel-vite-plugin';

export default defineConfig({
    plugins: [
        laravel({
            input: 'resources/js/app.js',
            ssr: 'resources/js/ssr.js',
        }),
    ],
});

Чтобы убедиться, что вы не забыли пересобрать точку входа SSR, мы рекомендуем дополнить скрипт «build» в вашем приложении, package.jsonчтобы создать сборку SSR:

"scripts": {
     "dev": "vite",
     "build": "vite build"
     "build": "vite build && vite build --ssr"
}

Затем, чтобы построить и запустить сервер SSR, вы можете выполнить следующие команды:

npm run build
node bootstrap/ssr/ssr.mjs


 @csrf - хэлпер, позволяющий подтвердить Laravel, что форма была отправлена из доверенного приложения.
Для этого следует добавить директиву @csrf в шаблон внутри формы.
При этом в HTML на стороне клиента при добавлении хелпера @csrf на его месте добавляется скрытый input,
в котором и передается тот самый токен.

Полезные методы класса RequestФ:
● method — возвращает строку, в которой содержится имя метода запроса.
● isMethod — возвращает bool-тип. Принимает строковый параметр и проверяет, соответствует
ли имя метода запроса переданной строке.
● has — принимает строковый параметр и проверяет, был ли передан данный элемент в форме.
Возвращает bool-тип.
● all — возвращает массив с данными, переданными в форме.
● input — принимает два параметра: имя элемента, который мы ожидаем из формы, и данные,
которые нужно заполнить, если этот элемент пуст или отсутствует. Второй параметр
необязателен.
● only — возвращает массив, состоящий только из тех элементов формы, которые переданы в
качестве параметров данного метода.
● except — возвращает массив, состоящий только из тех элементов формы, которые не
переданы в качестве параметров данного метода.
● path — возвращает url-путь без имени домена.
● url — возвращает url без get-параметров.
● fullUrl — возвращает полный url.
● query() — если вызывается метод без параметров, то возвращает массив всех параметров,
переданных методом get. Если передан параметр в качестве строки, то возвращает из get
значение данного параметра.

● flash() - сохраняет текущие данные в сессию (в "одноразовой" сессии).
● old() - позволяет прочитать данные из сессии.

<input type="text" value="{{ old('title') }}"> - позволит заполнить форму сохранёнными в сессии данными.


Хэлпер request()->routeIs('home') возвращает true, если адрес теущей страницы совпадает с названием маршрута ('home').
В сочетании с тернарным оператором удобно присваивать класс active текущему пункту меню:
<a class="nav-link {{ request()->routeIs('login') ? 'active' : '' }}" href="{{ route('login') }}">Login</a>

По умолчанию input type='checkbox' при установленной галочке возвращает 'on'.
Чтобы заменить значение, возвращаемое input type='checkbox', нужно присвоить ему атрибут value='нужное значение'.
Если checkbox не будет установлен, то значение для соответствующего name формы на сервер не придёт.

И показывать форму и обрабатывать данные, полученные через неё можно в одном методе.
Для этого маршрут нужно обработать с помощью метода Route::match(...);
  Route::match(['get', 'push'],'/create', [AdminNewsController::class, 'create'])->name('create');


Браузер определяет, что нужно делать с полученными из формы данными по полученным заголовкам.
Изображения принято хранить в папке Storage.
В образовательных целях временно будем хранить изображения в папке public.

Получить доступ к экземпляру класса Response можно с помощью хэлпера response().

С помощью метода download() класса Response можно скачать данные (при этом нужные загловки будут сформированы автоматически:
response()→download('fileName.ext');

Чтобы скачать данные формы в формате JSON, нужно использовать метод json():
response()→json()

public function test2(News $news)
{
	return response()→json($news→getNews()); - без указания заголовков
}

Метод контролера (как вариант) должен вернуть полученные данные.

    public function test2(News $news){							//инъекция зависимости от класса News
        return response()->json($news->getNews())					//используем метод getNews() класса News для получения всех новостей и преобразуем ответ в формат JSON
            ->header('Content-Disposition', 'attachment; filename = "news.txt"')	//указываем, что ответ нужно сохранить в виде файла
            ->setEncodingOptions(JSON_UNESCAPED_UNICODE | JSON_PRETTY_PRINT);		//преобразуем символы UNICODE (\u041D)  в кириллицу
    }

За пределами Laravel преобразовать кириллицу в UNICODE можно, например, так:
json_encode($str, JSON_UNESCAPED_UNICODE);

В /config/filesystems.php содержатся настройки, которые позволяют Laravel работать с файлами.
По умолчанию Laravel хранит скомпилилованные файлы приложения в папке /storage/app,
при этом данные, хранящиеся в папке /storage/app/public могут быть доступны извне сервера.

Для работы с файлами в контроллер необходимо подключить фасад Storage, который имеет
метод Storage::disk('название одного из дисков, указанных в файле /config/filesystems.php').
К данным, возвращаемым методом disk() можно применять методы
Storage::disk('disk_name')->get('filename.ext');	//чтение из файла
и
Storage::disk('disk_name')->put('filename.ext');	//запись в файл

В ДЗ потребуется news.json:
Storage::disk('local')->put('news.json', json_encode($news->getNews(), JSON_UNESCAPED_UNICODE | JSON_PRETTY_PRINT));
В результате будет создан файл в каталоге /storage/public.

В методе News::getNews() можно использовать
//json_decode('file_name', true); - по умолчанию возвращает объект, с опцией true возвращает массив

Для скачивания данных в формате xls или pdf можно использовать библиотеку Laravel excel

При работе в Laravel не следует использовать функции PHP file_get_contens() и file_put_contents(), т.к. это менее безопасно.

Пояснение ДЗ в видео - 1:29:30, 1:40:42, 1:47:30
ДЗ - создать страницу с формой "Скачать".
ДЗ - найти, как создать JSON-файл с помощью команды artisan

Настройка тестирования в Docker: 1:30:20
Для тестирования Laravel Sail в PHPStorm нажатием стрелки нужно установить и активировать плагины PHP и PHPDocker.
После этого в настройках PHP IDE нужно добавить новый CLI интерпретатор предварительно запустив контейнер Sail (при этом
 нужно в настройках сервера нажать кнопку "New").

Самый простой способ запустить тесты - использовать команду:

$php artisan test или $sail artisan test

Тестирование в Laravel:
https://www.youtube.com/watch?v=nef9Rozfp_U


Урок 5. Работа с базой данных. Запросы. Миграции

Метод для сохранения данных в файл:
public function save(News $news)
{
    \Illuminate\Support\Facades\Storage::disk('local')->put(
        'news.json',
        json_encode($news->getNews(),
        JSON_BIGINT_AS_STRING | JSON_PRETTY_PRINT));
}

Для создания пользовательской сервисной команды для artisan служит команда make:command,
которая создаёт файл ~app/Console/Commands/savejson.php:

sail artisan make:command savejson      //savejson - название команды
 INFO  Console command [app/Console/Commands/savejson.php] created successfully.

Файл ~app/Console/Commands/savejson.php содержит класс, расширяющий App\Console\Commands.
В нём нужно описать сигнатуру команды (protected $signature = 'save:json';),
а также переопределить метод обработчик handle();

При этом новая команда использует консольную точку входа в приложение.




php artisan help make:migration - вывести список доступных команд

Создадим новую таблицу для сохранения новостей. Для этого введем команду:
sail artisan make:migration create_news_table --create=news

Создался новый файл в директории ~/database/migrations. Открыв этот файл, увидим два метода:
up, который будет вызываться во время наката (выполнения) миграций, и down, который будет
выполняться, если придется откатить миграцию.
Cоздание файла миграций не означает его выполнение.

Фасад Schema — обертка для класса \Illuminate\Database\Schema\Builder.
create — статический метод фасада Schema,
первый параметр - название таблицы,
второй параметр - коллбек,
который в качестве параметра принимает объект класса Illuminate\Database\Schema\Blueprint
Благодаря методам класса Blueprint мы и создаем нужную структуру таблицы внутри самой функции.
У этого класса много методов, подробнее о них: https://laravel.com/docs/5.8/migrations#column
Разберем некоторые из них:
● bigIncrements — создает столбец первичного ключа с автоинкрементом. Принимает в
качестве параметра строку, которая и служит названием столбца;
● timestamps — добавляет в таблицу два столбца: created_at и updated_at;
● string — добавляет в таблицу столбец с типом данных VARCHAR. Первым параметром
принимает строку, которая будет именем столбца. Второй параметр необязательный — длина
строки;
● text — добавляет в таблицу столбец с типом данных TEXT. Первым параметром принимает
строку, которая будет именем столбца;
● json — добавляет в таблицу столбец с типом данных JSON. Первым параметром принимает
строку, которая будет именем столбца;
● bigInteger — добавляет в таблицу столбец с типом данных BIGINT. Первым параметром
принимает строку, которая будет именем столбца;
● dateTime — добавляет в таблицу столбец с типом данных DATETIME. Первым параметром
принимает строку, которая будет именем столбца;
● boolean — добавляет в таблицу столбец с типом данных BOOLEAN. Первым параметром
принимает строку, которая будет именем столбца.

Помимо основных методов, которые определяют тип данных столбца в таблице,
есть модификаторы колонок, которые позволяют установить дополнительные параметры столбца:
● default — метод указывает на то значение, которое будет установлено для колонки по
умолчанию;
● nullable — метод принимает true || false в качестве параметра и указывает, может ли быть
значение в данной колонке null.
● comment — принимает в качестве параметра строку, которая станет комментарием для
указанного столбца.
Данные модификаторы вызываются после определения типа столбца.

sail artisan migrate            //выполнить все миграций, которые есть в папке migrations
                                //(уже выполненные миграции повторно выполняться не будут)

sail artisan migrate:rollback   //отменить все миграции, которые были выполнены в данном предложении
                                //(таблица migrations сохранится).

sail artisan migrate:rollback --step=2      //откатить две последние миграции (указанные в таблице migrations)

В БД кроме таблиц, которые создаются при выполнении миграций, находящихся в папке migrations,
автоматически создаётся таблица migrations.
В таблице migrations хранится информация о тех миграциях, которые были выполнены.


Seeding — посев фейковых данных используется для тестирования приложения

sail artisan make:seeder NewsSeeder     //создать новый seeder
В папке ~database/seeds будет создан новый файл NewsSeeder.php
 — файл одноименного класса, в котором содержится единственный метод run,который будет выполняться при запуске seeder.

 Для заполнения базы данных фейковой информацией воспользуемся библиотекой fzaninotto/Faker.
 Предварительно установим ее через composer — команда для установки библиотеки:
 //устарело
 composer require fzaninotto/faker - библиотека не поддерживается.

 По умолчанию в Laravel входит https://packagist.org/packages/fakerphp/faker

Работа с seeder:
в методе run обращаемся к фасаду DB, который обратится к объекту класса \Illuminate\Database\Query\Builder.
Таким образом мы получим возможность добавлять данные в указанную таблицу.
У полученного объекта вызываем метод insert, который и будет производить данную вставку. Метод insert ожидает массив
данных, в котором ключи будут соответствовать полям таблицы.

Для генерации данных создаем отдельный метод getData и в нем обращаемся к библиотеке, которую
установили.
Обращаемся к статическому методу create и указываем локализацию.
После этого набираем массив из 10 подмассивов.

Каждый подмассив — отдельная строка в базе данных.

Для каждого подмассива собираем фейковые данные.
Для этого используем объект, сохраненный в переменной $faker, и вызываем соответствующие метод:
● sentence — метод класса Faker\Generator, возвращающий предложение, состоящее из указанного количества строк.
В данной библиотеке нет реализации данного метода на русском языке, поэтому результат на английском;
● realText — возвращает указанное количество слов из реального текста, минимум 10 и максимум 200.

Для запуска посева необходимо в консоли выполнить команду
 sail artisan db:seed --class=NewsSeeder
Seeders можно запускать любое количество раз.

Взаимодействие с базой данных
Для взаимодействия с базой данных воспользуемся фасадом DB и его методами.
select - позволяет использовать обычные SQL-запросы c возможностью экранировать данные, полученные от пользователя.
Статический метод Select принимает SQL-запрос, в результате которого получаем массив std-классов.
stdClass в PHP является предопределенным и часто используется для заполнения динамическими свойствами.
В метод select нельзя передавать данные, полученные от пользователя, без предварительной проверки (обработки),
т.к. они небезопасны.
Данные, полученные от пользователя могут содержать SQL-инъекцию (атака на базу данных).
Подробнее о  SQL-инъекциях можно прочитать в статье
https://habr.com/ru/post/148151/

Для защиты SQL-инъекций в Laravel используются подготовленные запросы.
Сначала базе говорится, какой запрос будет происходить, и указывается, куда в запросе нужно подставить данные.
Затем передаются данные и выполняется запрос.
Данные подставляются в строго отведенные им места, что исключает атаку.
Вторым параметром в Select передаем массив, ключом в котором указываем названия плейсхолдеров.
В значении передаем данные для подстановки.

DB::select(
    'SELECT id, title FROM news WHERE id = :id',
    ['id'=>$id]
);
В примере выше в SQL-запросе используется один плейсхолдер :id,
поэтому в массиве содержится одна пара «ключ —значение»: 'id'=> $id.

Помимо статичного метода для получения данных из базы, у фасада DB есть и другие:
● selectOne(string $query, array $bindings = []) — метод для поиска одной записи;
● select(string $query, array $bindings = []) — метод для выборки более чем одной записи;
● insert(string $query, array $bindings = []) — метод для вставки;
● update(string $query, array $bindings = []) — метод для изменения;
● delete(string $query, array $bindings = []) — метод для удаления;
● statement(string $query, array $bindings = []) — метод для запросов, не возвращающих результат.



Конструктор запросов

В практике работы с базой данных использование подхода, описанного выше, допустимо. Но он используется реже, чем
конструктор запросов.

У фасада DB существует метод table('название таблицы'),
возвращающий объект класса Illuminate\Database\Query\Builder.
Он содержит большое количество методов, которые используются для создания запросов к базе данных.
Пример:
$news = DB::table('news')->get();               //извлечь все строки из БД
$news = DB::table('news')->find($id);           //извлечь из БД строку с конкретным id

Примеры использования агрегатных функций count, max, min, avg и sum:
o DB::table('news')->count();
o DB::table('news')->max('id');

Примеры объединения таблиц:
$users = DB::table('users')
    ->join('contacts', 'users.id', '=', 'contacts.user_id')
    ->join('orders', 'users.id', '=', 'orders.user_id')
    ->select('users.*', 'contacts.phone', 'orders.price')
    ->get();

$users = DB::table('users')
    ->leftJoin('posts', 'users.id', '=', 'posts.user_id')
    ->get();

Примеры использования условий: where, orWhere, whereBetween, whereNotBetween, wherein, whereNotIn, whereNull,
whereNotNull, whereDate, whereMonth, whereDay, whereYear:
$users = DB::table('users')->where('votes', '=', 100)->get();

$users = DB::table('users')->where([
    ['status', '=', '1'],
    ['subscribed', '<>', '1'],
    ])->get();

$users = DB::table('users')
    ->where('votes', '>', 100)
    ->orWhere('name', 'John')
    ->get();

$users = DB::table('users')
   ->whereIn('id', [1, 2, 3])
   ->get();





 Конспект вебинара:

 В PHPStorm подключиться к контейнеру Docker можно с использованием вкладки Services,
 которая расположена рядом со вкладкой Terminal.

Значения переменных из контроллеров передаются в шаблоны с помощью сессий.
В контроллере при успешном действии создадим сессию с именем 'success' и выполним редирект на нужную странцу, а шаблон layout её получит и обработает (@if @else):

return redirect()->route('routeName')->with('success', 'message text');

Благодаря использованию сессии 'success' в layout сообщения можно будет выводить на любой странице,
которая использует его.

Чтобы добавить компонент Alert Bootstrap, всплывающий после добавления новости можно использовать "одноразовую" сессию с ключом 'success':
нужно добавить его в layout (в шаблоне страницы у меня не сработал) и
сделать условный рендеринг. Перед этим нужно передать из контроллера ->with('success', "Новость успешно добавлена!").

 @if(session('success'))
    <div>{{ session('success') }} </div>
 @endif



 В   ~/config/database.php хранятся настройки подключения к БД.
 sqlite используется для тестирования.

 Хэлпер env('key', default) берёт значения указанного свойства из файла .env

 При использовании Sail в .env настройки подключения к БД будут такими
 (подключение к БД, которая запущена внутри контейнера Docker):

 DB_CONNECTION=mysql
 DB_HOST=mysql              //? будет использовано дефолтное значение '127.0.0.1', указанное в ~/config/database.php
 DB_PORT=3306
 DB_DATABASE=example_app
 DB_USERNAME=sail
 DB_PASSWORD=password,

 а при работе локально c OpenServer:

 DB_CONNECTION=mysql
 DB_HOST=127.0.0.1
 DB_PORT=3306
 DB_DATABASE=laravel
 DB_USERNAME=root
 DB_PASSWORD=

 Подключиться к БД можно двумя способами: через фасад DB

 В дальнейшем методы для работы с БД должны располагаться в контроллере, а не в модели.
 Извлечение нужных данных будет реализовано средствами БД, а не PHP.

 Для упрощённого просмотра БД в контейнере Docker можно использовать HeidiSQL.
В настройках подключения к БД HeidiSQL требуется указать имя хоста/IP
(в .env указано DB_HOST=mysql).
Чтобы определить внешний IP-адрес контейнера Docker Sail в виртуальной среде Linux,
командная строка которой появляется после ввода команды wsl,
ввести команды:
$ sudo apt install net-tools
$ ifconfig
Эта команда выведет параметры сети внешнего eth0 и внутреннего lo соединений.
Нам требуется внешний ip-адрес контейнера.
У меня он 172.17.88.101.
Остальные данные для настройки подключения в HeidiSQL я взял в .env.

Чтобы реализовать возможность работы над одним проектом нескольких разработчиков с помощью Git,
используется механизм миграций.
Таблицы создаются с помощью PHP-команд.
Каждой таблице в БД соответствует отдельный PHP-файл.
Это позволяет всем разработчикам иметь актуальную версию БД после git pull.

Для создания миграций используются библиотеки.
В Laravel библиотека для создания миграций входит по умолчанию.
Laravel/Database/Getting started

Перед выполнением миграций нужно вручную создать пустую БД, например, при развёртывании проекта на хостинге. Имя БД должно совпадать с указанным в .env

Чтобы создать структуру БД нужно создать файлы миграций, а затем их выполнить.
По умолчанию в Laravel имеется несколько миграций: ~/database/migrations/,
в том числе, для создания таблицы users.

Файлы миграций (заготовки)  создаются с помощью команды
$ sail artisan make:migration name_migration

Команда создания модели автоматически с ключом -m автоматически создаёт и миграции для неё:
$ sail artisan make:model ModelName -m

Имя файла миграции должно содержать имя таблицы и описывать то, что с ней происходит:
create - создание таблицы
$ sail artisan make:migration create_news_table         //создание таблицы новости

Для выполнения миграций (внесения изменений в структуру БД) нужно выполнить команду:
$ sail artisan migrate

Для "отката" изменений, внесённых в БД последней миграцией
(командой $ sail artisan migrate)
используется команда:
$sail artisan migrate:rollback

Для добавления столбца category_id  в таблицу news необходимо создать миграцию командой:
sail artisan make:migration add_category_id_column_to_news_table --table=news

Для заполнения таблиц фейковыми данными используется "посев" Seeding
Seeders располагаются в ~/database/seeders/

Фабрики сидеров находятся в ~/database/factories/ - с помощью них удобно производить "посев". Пока обойдёмся без них.

Для создания файла для заполнения БД данными используется команда:
$ sail artisan make:seeder TableNameSeeder      //на первом месте - название таблицы + Seeder

В ~/database/seeders/DatabaseSeeder.php и во всех сидерах имеется метод run((), который выполняет "посев".

Библиотека Faker предустановлена в Laravel по-умолчанию (composer.json).
Документацию по Faker можно найти на сайте  https://packagist.org/.
Внутри сидера новостей создадим метод getData(), который будет возвращать случайные данные (с помощью Faker),
которыми будет заполняться таблица БД.

Если Seeder или другой класс не подключается автоматически (не попадает в автозагрузчик),
возникает ошибка "Класс не найден",
то нужно выполнить команду:

composer dump-autoload

Пример Seeder:
<?php
namespace Database\Seeders;

use Illuminate\Database\Seeder;
use Faker;
use Illuminate\Support\Facades\DB;

class NewsSeeder extends Seeder
{
    /**
     * Run the database seeds.
     *
     * @return void
     */
    public function run()
    {
        DB::table('news')->insert($this->getData());
    }

    public function getData()
    {
        $data = [];
        //создаёт локализованный для русского языка экземпляр класса Faker.
        $faker = Faker\Factory::create('ru_Ru');
        //для создания массива новостей используем цикл
        for ($i = 0; $i < 5; $i++) {
            $data[] = [
                'title' => $faker->realText(rand(10, 30)),
                'text' => $faker->realText(rand(1000, 3000)),
                'isPrivate' => $faker->boolean()
            ];
        }
        return $data;
    }
}

  $faker = Faker\Factory::create('ru_Ru');      //создаёт локализованный для русского языка экземпляр класса Faker.

  Если обращаться к БД напрямую (не использую фасад DB), то будет утеряно кэширование и безопасность и т.п.,
  предоставляемые  фреймворком.

      /*  DB::table('tableName')->insert(массив или массив массивов);
        Если передать один массив - то в таблицу будет добавлена одна строка и метод вернёт её id,
        если передать массив массивов, то будет добавлено число строк, равное количеству элементов внешнего массива.*/
        DB::table('news')->insert($this->getData());

Для запуска сидера используется команда:
$ sail artisan db::seed --class=ClassNameSeeder,
где ClassNameSeeder - название класса сидера.

Если в БД много таблиц, то выполнять посев данных в каждую из них отдельной командой затратно, поэтому используется
класс DatabaseSeeder, который присутствует в Laravel по умолчанию и содержит метод run().
Последовательность запуска сидеров внутри run() имеет значение:
сначала нужно засеивать таблицы, столбцы в которых не ссылаются на другие таблицы
(т.к. сначала таблица категорий, а потом таблица новостей, которые относятся к категориям),
чтобы избежать ошибок.

        //вызов нужного seeder
        $this->call(NewsSeeder::class);

//Очистить БД, перезапустить миграции, засеять БД данными
$ sail artisan migrate:fresh --seed

Чтобы извлечь данные из БД нужно использовать фасад DB.
Например:
$news = DB::select('SELECT * FROM `news` WHERE 1');     //возвращает объект
Использовать метод select можно только в исключительных случаях,
когда невозможно обойтись средствами конструктора запросов.

Методы фасада DB (например get()) возвращают коллекции,
т.е. массивы, элементы которых являются объектами, содержащими данные и методы
для работы с ними.
Чтобы преобразовать их в массив, можно использовать метод ->get()->toArray(),
но делать это не рекомендуется, т.к. теряется гибкость,
кроме того, лишние действия снижают производительность приложения.

get()       - возвращает все данные из таблицы,
find($id)   - возвращает строку таблицы с id = $id.

  StyleGuide:
  имена классов сущностей называть в единственном числе (каждый экземпляр модели содержит одну запись БД) с заглавной
  буквы,
  а таблицам, хранящим данные этих сущностей, во множественном с маленькой.

Механизм миграций реализует функционал системы контроля версий при работе с БД.
Миграции позволяют собирать БД вне зависимости от исходного состояния,
т.к. при запуске миграции будут выполняться только те, которые ещё не выполнялись (новые).

sail artisan migrate:fresh      //удалить все таблицы из БД и запустить все миграции

 В ~/database/migrations/ хранятся файлы миграций.
 В каждой миграции есть методы:
  up() - для внесения изменений в БД
  down() - для отката изменений.

  метод ->id() создаёт первичный ключ (автоинкремент, всё что нужно),
  ранее вместо него использовался метод ->bigIncrements('id').
  ->default(value) - дефолтное значение
  ->comment(string)- комментарий к названию столбца
  ->string(string) - короткая строка
  ->text(string) - длинный текст
  Методы для создания полей подробно описаны в документации на сайте в разделе Migrations.
  00:40 - пример создания миграции (применение методов для создания полей нужных типов).


1. Продумать структуру сохранения данных следующих таблиц:
a. Новости.
b. Категории новостей по образцу.
c. Источники получения новостных данных.
Структура может быть реализована в виде рисунка, таблиц или специальных диаграмм.

2. Сделать миграции для таблиц из первого задания. Миграции должны иметь роллбеки.
sail artisan make:migration create_categories_table
sail artisan make:seeder CategoriesSeeder


3. С помощью сидинга реализовать заполнение созданных таблиц фейковыми данными.
Таблица категорий — минимум 5 записей. Таблица новостей — минимум 10 записей на
каждую категорию. Таблица источников — минимум 10 записей.

4. Удалить созданные методы в контроллере для хранения данных и реализовать вывод данных
из базы.

Связи между таблицами делать не нужно.
Подумать как извлечь новости конкретной категории.

Нужно переделать метод create() в Adminj\NewsController.php.
Вместо Storage::disk() - insert(),
если идёт редирект на эту новость, то insertGetId() - возвращает id добавленной записи.
Подробнее о ДЗ 1:31, 1:33
Продолжить просмотр с 1:39 (добавление картинки в HTML)

Чтобы файлы, находящиеся в папке ~/storage стали доступны в браузере,
нужно создать символическую ссылку (ярлык) командой:
$ sail artisan storage:link
   INFO  The [public/storage] link has been connected to [storage/app/public].

Конспект лекции №6: Работа с базой данных. Eloquent ORM. Laravel Debugbar

Laravel Debugbar - внешний компонент. Его аналог присутствует в Laravel UI.
Помогает получать большое количество отладочной информации (например, Request) прямо в окне браузера без использования dump().

Искать на packagist.org (barryvdh/laravel-debugbar)
sail composer require barryvdh/laravel-debugbar --dev

ORM (англ. Object-Relational Mapping, рус. объектно-реляционное отображение, или преобразование) — технология программирования, которая связывает базы данных с концепциями объектно-ориентированных языков программирования, создавая «виртуальную объектную базу данных».

DB:: - надстройка над библиотекой PDO

Создать модель extends Model:
sail artisan make:model ModelName

use HasFactory внутри тела класса означает использование трейта HasFactory.

Класс Model имеет большое количество полей, например:
    protected $table;               название таблицы
    protected $primaryKey = 'id';   первичный ключ
в классе наследнике их можно переопределять.

Создание класса модели (даже созданного по умолчанию - без редактирования)
позволяет использовать ORM, т.к. на самом деле он не пуст, потому что встроенный в Laravel класс Model, от которого наследуются пользовательские модели, имеет большое количество полей и методов для работы с ними:
для получения данных из БД вместо фасада DB использовать фасад,
соответствующий названию класса модели.
Например:
$news = DB::table('news')->get();
идентично
$news = News::all();    //возвращает коллекцию - массив объектов класса-модели
Каждый объект коллекции содержит не только данные, но и методы для работы с ними.

$news = DB::table('news')->find($id);
идентично
$news = News::query()->find($id);
метод query() берёт имя таблицы из самой модели News.

ORM упрощает использование маршрутов с параметрами.
Если имя параметра в маршруте совпадает с именем модели (/{news}), и в методе контроллера в качестве параметра
используется
название модели (News $news), то в контроллере будет создан (вернее, получен из контейнера) не пустой объект News, а
соответствующий переданному в маршруте параметру.
Т.е. из БД будет возвращаться строка со значением первичного ключа, равным переданному в адресной строке браузера, либо
произойдёт перенаправление на страницу '404'.
Кроме того, в представлениях в динамических маршрутах, в которых используются экземпляры класса-модели, не требуется
указывать первичный ключ таблицы, т.к. Laravel извлечёт его и подставит в маршрут по-умолчанию.
Например:
href="{{ route('news.show', $item->id) }}"
идентично
href="{{ route('news.show', $item) }}",
т.е. разработчику не требуется помнить название первичного ключа модели.

Принцип работы фасада - при необходимости будет создан экземпляр класса и помещён в контейнер.
При повторном обращении к классу новый экземпляр создаваться не будет, а будет браться из контейнера.

Пример запроса с использованием ORM (AR):
выводит неприватные новости:
$news = News::query()->where('isPrivate', false)->get();
сработает даже так:
$news = News::where('isPrivate', false)->get();


Пагинация.

$news = News::query()->paginate($n); - возвращает не коллекцию, а объект paginator, одним из свойств которого является
коллекция объектов нужного класса. Кроме того, имеются методы для работы с данными объекта:
{{ $news->links() }} - по умолчанию в шаблоне для пагинации будут использованы стили TailWind, но их можно изменить на
пользовательские.
Для применения пользовательских стилей к пагинации можно в ~/app/Providers/AppServiceProvider.php зарегистрировать новые
компоненты функционала в методе register(), а в методе boot() указать инициализации, которые будут происходить при
загрузке.
Paginator::useBootstrap(); //применить стили Bootstrap к пагинации при загрузке


Работа с коллекциями

Хэлпер collect([]) возвращает объект класса-коллекции Illuminate\Support\Collection, который имеет очень много методов
для работы с данными, которых не имеют обычные массивы, например, найти дубли, объединять, count, min, max, last, first,
 sort и т.п..
 Например:
 ->keyBy('id'); // позволяет привести первичные ключи коллекции (аналог номеров элементов в массиве) в соответствие
 указанному в качестве параметра ключу объектов, входящих в
 коллекцию.
 ->diff();      //найти отличия

$collection = collect([1,2,3]);

Если не использовать библиотеку Laravel/UI, то пользовательские стили (в том числе и Bootstrap) и  скрипты нужно
подключать в теге
head:
<script src="{{ asset('js/app.js' }}" defer></script>
<link href="{{ asset('css/app.js' }}" rel="stylesheet"></script>



Вместо ->get()[0] пишите first()
