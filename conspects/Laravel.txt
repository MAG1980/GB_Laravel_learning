При внесении изменений в файл .env под Windows к нему применяется кодировка DOS и возникают ошибки
./.env: line 6: $'\r': command not found
Преобразовать кодировку обратно можно с помощью команды:
$ dos2unix .env .env
dos2unix: converting file .env to Unix format...

Возникала ошибка
SQLSTATE[HY000] [1044] Access denied for user 'sail'@'%' to database 'example_app' (SQL: select * from information_schema.tables where table_schema = example_app and table_name = migrations and table_type = 'BASE TABLE')

Решил с помощью этой инструкции:
https://gist.github.com/jjsquady/e12ce89c9029d520ce08f60a9ff8f304
Выполнил команды:
docker-compose exec mysql bash

bash-4.4# mysql -u root -p
Enter password:
password (символы не отображаются)

mysql> mysql -u root -p

mysql> GRANT ALL PRIVILEGES ON *.* TO 'sail'@'%';
Query OK, 0 rows affected (0.01 sec)

mysql> FLUSH PRIVILEGES;
Query OK, 0 rows affected (0.01 sec)

mysql> EXIT;


Советы по работе с Docker:

если идти на 127.0.0.1, то надо указывать внешний  порт проброса.
если идти на  172.17.88.101  то надо идти на внутренний.

то есть проброс

ports : 33060:3306
первый внешний, второй внутренний.

А  еще, есть команда docker inspect,
которая покажет всю инфу по контейнеру.



Чтобы удалить пакет из проекта нужно использовать откат в Composer:
удалить строчку пакета в json и папку vendor и сделать install

Чтобы подключиться к удалённому репозиторию, пришлось создать ветку dev.
$ git pull выдавала ошибку.
--------------------------------------------------------------
$ git pull
У текущей ветки нет информации об отслеживании.
Пожалуйста, укажите с какой веткой вы хотите слить изменения.
Для дополнительной информации, смотрите git-pull(1).

    git pull <внешний-репозиторий> <ветка>

Если вы хотите указать информацию о отслеживаемой ветке, выполните:

    git branch --set-upstream-to=origin/<ветка> dev
----------------------------------------------------------
Сработала команда, где  origin/dev — название «удалённой» ветки,
а dev — название локальной.

$ git branch --set-upstream-to=origin/dev dev
Ветка «dev» отслеживает внешнюю ветку «dev» из «origin».
$ git pull
fatal: отказ слияния несвязанных историй изменений
$ git fetch
$ git reset --hard origin/dev
Указатель HEAD сейчас на коммите f87ae1f Начало практики к уроку №2. Создан HomeController.
alexey@pc34:~/PhpstormProjects/Laravel-learning$ git pull

Проблема подключения к внешнему репозиторию решена.


wsl - запустить Linux в Windows

Чтобы создать новое приложение Laravel в каталоге с именем «example-app», вы можете запустить следующую команду в своем терминале:
curl -s https://laravel.build/example-app | bash - установка Laravel Sail

./vendor/bin/sail up - запустить Sail

Установка Laravel Sail

Linux:

    Follow the official install instructions for Docker CE/EE for your distribution. If you are using Docker Compose, follow the Docker Compose directions as well.

 !!!   Add your user to the docker group by using a terminal to run: sudo usermod -aG docker $USER      !!!

    Sign out and back in again so your changes take effect.


Чтобы подключиться к виртуальной Linux из PHPStorm нужно в его терминале ввести команду wsl.

alias sail="bash ./vendor/bin/sail" - создание псевдонима для команды запуска проекта (нужно создавать и запускать из папки проекта).

С использованием псевдонима:
sail up -d - с отсоединением консоли

Урок 2. Роутинг. Использование контроллеров

В старых версиях PHPStorm может потребоватья настроить IDEHelper (ServiceProvider).
Сейчас IDE берёт список методов из PHPDoc класса.

Маршруты хранятся в папке routes.
Маршруты SSR хранятся в файле web.php
Маршруты SPA хранятся в файле api.php

Маршруты задаются с помощью статических методов класса Route, который наследуется от фасада.
Laravel при первом обращении к классу Router создаёт в контейнере его экземпляр.
Реализация паттерна Facade позволяет скрыть сложную релализацию за простым фасадом.

При создании маршрута в первую очередь указывается его HTTP-метод.
Route::get (post), который первым параметром принимает адрес, а вторым - коллбек-функцию-обработчик,
которая возвращает нужный хэлпек view или сразу данные (HTML?).

Route::match(['post', 'get']) - статический метод класса Route,
позволяющий обрабатывать все HTTP-методы, указанные в массиве.

Представления - view хранятся в ~/resources/views


Route::get('/info', function () {
    return view('info');
});
эта запись аналогична следующей:
Route::view('/info', 'info');
});


Вместо view можно передать HTML-разметку:
Route::view('/test', 'test');

Передать данные в представление ('news' - переменная, $news - значение)
        view('news.news')->with ('news', $news);

Первый параметр - alias,
второй параметр - название шаблона,
третьим параметром можно передать ассоциативный массив со значениями переменных шаблона.
В маршрут можно передать значения переменных в виде массива, который передаётся третим параметром:
Route::view('/', 'index', [
	'name' => 'Admin'
]);


В этом варианте не используются модель и контроллер.
Это можно делать, если передача данных в шаблон не требуется.

Более правильный вариант - с использованием контроллера:
Route::get('/', [HomeController::class, index]);
HomeController - класс, который наследуется от Controller и содержит метод-обработчик (index).

slug — осмысленное строковое значение. Как правило с символами подчеркивания (или точки) вместо пробелов

Пример маршрута с параметром:
Route::get('/{slug}', [HomeController::class, index]);

значение slug будет доступно в параметре ($slug) метода index контроллера HomeController,
при этом важно не забыть её принять: public function index($slug)

Route::get('/{category}/buy/{slug}', [HomeController::class, index]);
Если параметров маршрута несколько, то их нужно перечислить через запятую: public function index($category, $slug)

StyleGuide:
Важно -
при создании маршрутов, псевдонимов маршрутов, методов-обработчиков маршрутов в контроллерах, представлений
следует придерживаться одинаковых именований:
Route::get('/create', [AdminNewsController::class, 'create'])->name('create');



Чтобы создать HomeController, используя средства Laravel, нужно ввести команду
$ sail artisan make:controller HomeController
Эта команда будет вызывать ошибку, если в приложении уже есть строка,
в которой происходит обращение к несуществующему контроллеру (её нужно предварительно закомментировать),
т.к. перед выполнением команды artisan выполняет код приложения.


sail artisan help make:controller

Artisan - интерфейс командной строки, который в Laravel используется для ввода команд,
ускоряющих разработку приложения (для автоматической генерации кода).
Дли использования artisan нужно выполнить команду: $ php artisan
При использовании Laravel Sail: $sail artisan

Чтобы получить подробную информацию по команде, следует указать после artisan слово help и имя нужной команды.
Например:
$ sail artisan help make:controller




Для перенаправления на другую страницу используется метод redirect:
Route::redirect('маршрут', 'маршрут, на который осуществляется перенаправление', код ответа сервера);
Route::redirect('redir', '/', 301);

Кастомную страницу 404 можно сделать с помощью метода fallback:
Route::fallback(function (){
	return view('beauty_404');
});

!!! Маршрут страницы 404 должен располагаться в самом низу списка маршрутов.

Если из БД вместо данных получен NULL, то в контроллере следует сделать редирект на "404" .
if(is_null($data)){
	return redirect()->action([HomeController::class, 'index']);
}

$ php artisan route:list - выводит список зарегистрированных маршрутов
$ php artisan route:list --except-path=api,_ignition,sanctum - вывести только пользовательские маршруты

$ php artisan route:cache - кешировать маршруты.
После этого Laravel берёт информацию о маршрутах не из папки routes, а из кеша.
Кеширование маршрутов обязательно нужно делать на рабочем сервере (в ProductionMode), т.к. сборка маршрутов занимает много времени.
$ php artisan route:clear

!!! При использовании Laravel Sail вместо php нужно писать sail
sail artisan route:list

Если не использовать сырую разметку (вывод через {!! .... !!} ) и использовать валидаторы (либо в контроллерах, либо FormRequest, то ларка вполне безопасна)))
при ошибке валидации автоматом же в old значения попадут и будет редирект обратно в форму

Помещать функционал контроллера в роутер - плохая идея.

В Laravel контроллеры хранятся в папке ~/api/Http/Controllers, в том числе базовый класс Controller.

Хэлпер dump используется для отладки.
Он позволяет вывести информацию о значении переменной без остановки вывода.

Хэлпер dd выводит информацию о значении переменной с остановкой вывода.

Дополнительное ДЗ от преподавателя:
1:40 -

Контроллеры принято разносить по разным папкам.
Например, контролеры для путей, доступны только админу будем хранить в папке Admin.

Route::get('/admin', [
	'uses' => 'Admin\IndexController@index' — после @ указано название метода
]);


Чтобы устранить ошибки после подключения репозитория к Ubuntu пришлось стать владельцем папки проекта с помощью команды:
sudo chmod o+w ./Laravel-learning/ -R



$ sail artisan tinker — позволяет вывести значение какого-либо хэлпера:

root@pc34:/home/alexey/PhpstormProjects/Laravel-learning# sail artisan tinker
Psy Shell v0.11.8 (PHP 8.1.11 — cli) by Justin Hileman
>>> view('index')
=> Illuminate\View\View {#3673}

>>> route('home')
Symfony\Component\Routing\Exception\RouteNotFoundException with message 'Route [home] not defined.'
>>> route('404')
=> "http://localhost/404"

Иногда вам может понадобиться запустить сеанс Bash в контейнере вашего приложения.
Вы можете использовать эту shell команду для подключения к контейнеру вашего приложения,
что позволит вам проверять его файлы и установленные службы, а также выполнять произвольные команды оболочки внутри контейнера:

sail shell
 
sail root-shell

Чтобы передать в шаблон псевдоним маршрута необходимо использовать хэлпер route()
route('имя маршрута', 'параметр запроса (необяз.)')

<a href="<?=route('news.one', $item['id']) ?>"><?= $item['title'] ?></a><br>


Чтобы выделить текущий пункт меню можно использовать хэлпер named('имя маршрута')
/**
 * Handle an incoming request.
 *
 * @param  \Illuminate\Http\Request  $request
 * @param  \Closure  $next
 * @return mixed
 */
public function handle($request, Closure $next)
{
    if ($request->route()->named('profile')) {
        //
    }
 
    return $next($request);
}
или

Route::is('имя маршрута'):boolean


Для группировки маршрутов по имени используется хэлпер Route::name('имя маршрута'), а для группировки по префиксу Route::prefix('префикс')

StyleGuide: Route::name('имя маршрута') - имя маршрута должно быть таким же, как имя шаблона или имя метода контроллера.

Для группировки маршрутов используется хэлпер group(callback):

Route::name('admin.')
    ->prefix('admin')
    ->group(function () {
        Route::get('/', [IndexController::class, 'index'])->name('index');
        Route::get('/test1', [IndexController::class, 'test1'])->name('test1');
        Route::get('/test2', [IndexController::class, 'test2'])->name('test2');

    });

Маршруты можно группировать и по namespace: Route::namespace('namespace')

Для перенаправления на нужный маршрут в случае отстутствия нужной страницы (данных)
использутеся хэлпер ->missing(function(
	{
		return view('product.not_found');
	}));


Для SEO важно в маршрутах использовать слова:
/news/category/1 	- плохо
/news/category/sport	- хорошо

Str::slug - Метод генерирует дружественный URL-адрес "slug" из заданной строки:
use Illuminate\Support\Str;
$slug = Str::slug('Laravel 5 Framework', '-');


Советы к ДЗ:
Добавить в массивы новостей и категорий ключи ID, которые совпадают с id новости или категории, чтобы не искать новость перебором.

https://www.youtube.com/watch?v=8X77WSGg29c


Laravel Livewire используется для создания динамических интерфейсов без использования JS, Vue или React.
Laravel Livewire - спорная ("игрушечная" технология),
т.к., например, во время ввода данных в input, на сервер посылается огромное количество запросов,
что приводит к перегрузке сервера.

Правильнее будет использование JavaScript-фреймворка Alpine.js

Шаблонизатор даёт скорость, гибкость и безопасность.

Шаблонизатор Blade позволяет писать PHP-код внутри {{ }}, т.е. даже вызывать PHP-функции,
поэтому внутри {{ $varable }} перед именем переменной нужно ставить знак $.
JavaScript-код, содержащийся в переменной, выводимой в шаблон, будет экранирован.
Чтобы отключить экранирование Javascript нужно использовать {!! $variable !!}

Поскольку многие фреймворки JavaScript также используют «фигурные» скобки для обозначения того,
что данное выражение должно отображаться в браузере, вы можете использовать @символ,
чтобы сообщить механизму рендеринга Blade, что выражение должно оставаться нетронутым.
Например:

<h1>Laravel</h1>
Hello, @{{ name }}.

В этом примере @символ будет удален Blade;
тем не менее, {{ name }}выражение останется нетронутым движком Blade,
что позволит вам отображать его с помощью вашей инфраструктуры JavaScript.

Этот @символ также может использоваться для экранирования директив Blade:

{{-- Blade template --}}
@@if()
<!-- HTML output -->
@if()

Если вы отображаете переменные JavaScript в большей части своего шаблона,
вы можете обернуть HTML в @verbatimдирективу,
чтобы вам не нужно было префикс каждого оператора эха Blade @символом:

@verbatim
    <div class="container">
        Hello, {{ name }}.
    </div>
@endverbatim

Экранирование рендеринга атрибутов
Поскольку некоторые фреймворки JavaScript, такие как Alpine.js,
также используют атрибуты с префиксом двоеточия, вы можете использовать префикс с двойным двоеточием ( ::),
чтобы сообщить Blade, что атрибут не является выражением PHP. Например, для следующего компонента:

<x-button ::class="{ danger: isDeleting }">
    Submit
</x-button>

Следующий HTML будет отображаться Blade:

<button :class="{ danger: isDeleting }">
    Submit
</button>



Макеты с использованием наследования шаблонов

Директива @section, как следует из названия, определяет раздел содержимого,
а @yield директива используется для отображения содержимого данного раздела.

<!-- resources/views/layouts/app.blade.php -->

<html>
    <head>
        <title>App Name - @yield('title')</title>
    </head>
    <body>
        @section('sidebar')
            This is the master sidebar.
        @show
        <div class="container">
            @yield('content')
        </div>
    </body>
</html>

Расширение макета
При определении дочернего представления используйте @extends директиву Blade, чтобы указать, какой макет дочернее представление должно «наследовать».
Представления, расширяющие макет Blade, могут вставлять содержимое в разделы макета с помощью @section директив.
Помните, как видно из приведенного выше примера, содержимое этих разделов будет отображаться в макете с помощью @yield:

<!-- resources/views/child.blade.php -->

@extends('layouts.app')
@section('title', 'Page Title')
@section('sidebar')
    @parent
     <p>This is appended to the master sidebar.</p>
@endsection
@section('content')
    <p>This is my body content.</p>
@endsection

В этом примере sidebarраздел использует @parentдирективу для добавления (а не перезаписи) контента на боковую панель макета.
Директива @parentбудет заменена содержимым макета при отображении представления.


Для подключения Vue, React или Bootstrap к Laravel можно использовать пакет Laravel/UI
https://packagist.org/packages/laravel/ui#v4.0.2
с помощью команды:
composer require laravel/ui

Для установки пакета Laravel/UI в контейнер Docker (Laravel Sail)
нужно сначала запустить конетейнер командой sail up,
а затем выполнить команду

sail composer require laravel/ui

Далее следовать инструкции на сайте https://packagist.org/packages/laravel/ui#v4.0.2

Например, чтобы подключить Vue с Bootstrap и автоматическим созданием шаблонов форм авторизации, нужно выполнить команду:

sail artisan ui vue --auth

При этом автоматически будут созданы:

resources/views/layouts/app.blade.php
resources/js/components/ExampleComponent.vue
resources/js/app.js
resources/js/app.bootstrap.js
и т.п.


Вообще, чтобы выполнять любые команды внутри контейнера Docker,
в том числе и npm,
нужно обязательно вводить префикс ./vendor/bin/sail (или использовать алиас sail), например:

sail npm run dev - чтобы запустить live-server для разработки UI

sail npm run build - сборка Frontend (css и JS) для production



Для подключения ресурсов (стилей и JS) в шаблонах нужно использовать директиву @vite (образец - в app.blade.php, который сгенерировал laravel/ui):

 @vite(['resources/sass/app.scss', 'resources/js/app.js'])

где перечислены точки входа стилей и JS. Остальные стили должны подключаться в точке входа через директиву @import.
(В точке входа (файле resources/sass/app.scss) подключить свои стили с помощью директивы @import 'my-app.scss';)

При разработке SPA точку входа CSS лучше не использовать.
Вместо этого стили нужно импортировать в resources/js/app.js файле вашего приложения:

import './bootstrap';
import '../css/app.css';


Необходимо сообщить Vite о ваших ресурсах, импортировав статические ресурсы в точку входа приложения.
Например, если вы хотите обрабатывать и версионировать все изображения,
хранящиеся в , resources/imagesи все шрифты,
хранящиеся в resources/fonts,
вы должны добавить следующее в resources/js/app.jsточку входа вашего приложения:

import.meta.glob([
  '../images/**',
  '../fonts/**',
]);

Эти активы теперь будут обрабатываться Vite при запуске npm run build. Затем вы можете ссылаться на эти активы в шаблонах Blade, используя Vite::assetметод, который вернет версионный URL-адрес для данного актива:

<img src="{{ Vite::asset('resources/images/logo.png') }}">


Рендеринг на стороне сервера (SSR)
Плагин Laravel Vite упрощает настройку рендеринга на стороне сервера с помощью Vite. Для начала создайте точку входа SSR resources/js/ssr.jsи укажите точку входа, передав параметр конфигурации плагину Laravel:

import { defineConfig } from 'vite';
import laravel from 'laravel-vite-plugin';

export default defineConfig({
    plugins: [
        laravel({
            input: 'resources/js/app.js',
            ssr: 'resources/js/ssr.js',
        }),
    ],
});

Чтобы убедиться, что вы не забыли пересобрать точку входа SSR, мы рекомендуем дополнить скрипт «build» в вашем приложении, package.jsonчтобы создать сборку SSR:

"scripts": {
     "dev": "vite",
     "build": "vite build"
     "build": "vite build && vite build --ssr"
}

Затем, чтобы построить и запустить сервер SSR, вы можете выполнить следующие команды:

npm run build
node bootstrap/ssr/ssr.mjs


 @csrf - хэлпер, позволяющий подтвердить Laravel, что форма была отправлена из доверенного приложения.
Для этого следует добавить директиву @csrf в шаблон внутри формы.
При этом в HTML на стороне клиента при добавлении хелпера @csrf на его месте добавляется скрытый input,
в котором и передается тот самый токен.

Полезные методы класса RequestФ:
● method — возвращает строку, в которой содержится имя метода запроса.
● isMethod — возвращает bool-тип. Принимает строковый параметр и проверяет, соответствует
ли имя метода запроса переданной строке.
● has — принимает строковый параметр и проверяет, был ли передан данный элемент в форме.
Возвращает bool-тип.
● all — возвращает массив с данными, переданными в форме.
● input — принимает два параметра: имя элемента, который мы ожидаем из формы, и данные,
которые нужно заполнить, если этот элемент пуст или отсутствует. Второй параметр
необязателен.
● only — возвращает массив, состоящий только из тех элементов формы, которые переданы в
качестве параметров данного метода.
● except — возвращает массив, состоящий только из тех элементов формы, которые не
переданы в качестве параметров данного метода.
● path — возвращает url-путь без имени домена.
● url — возвращает url без get-параметров.
● fullUrl — возвращает полный url.
● query() — если вызывается метод без параметров, то возвращает массив всех параметров,
переданных методом get. Если передан параметр в качестве строки, то возвращает из get
значение данного параметра.

  Хэлпер old() используется в случае неудачной валидации

● flash() - сохраняет текущие данные в сессию (в "одноразовой" сессии).
● old() - позволяет прочитать данные из сессии.

<input type="text" value="{{ old('title') }}"> - позволит заполнить форму сохранёнными в сессии данными.



Хэлпер request()->routeIs('home') возвращает true, если адрес теущей страницы совпадает с названием маршрута ('home').
В сочетании с тернарным оператором удобно присваивать класс active текущему пункту меню:
<a class="nav-link {{ request()->routeIs('login') ? 'active' : '' }}" href="{{ route('login') }}">Login</a>

По умолчанию input type='checkbox' при установленной галочке возвращает 'on'.
Чтобы заменить значение, возвращаемое input type='checkbox', нужно присвоить ему атрибут value='нужное значение'.
Если checkbox не будет установлен, то значение для соответствующего name формы на сервер не придёт.

И показывать форму и обрабатывать данные, полученные через неё можно в одном методе.
Для этого маршрут нужно обработать с помощью метода Route::match(...);
  Route::match(['get', 'push'],'/create', [AdminNewsController::class, 'create'])->name('create');


Браузер определяет, что нужно делать с полученными из формы данными по полученным заголовкам.
Изображения принято хранить в папке Storage.
В образовательных целях временно будем хранить изображения в папке public.

Получить доступ к экземпляру класса Response можно с помощью хэлпера response().

С помощью метода download() класса Response можно скачать данные (при этом нужные загловки будут сформированы автоматически:
response()→download('fileName.ext');

Чтобы скачать данные формы в формате JSON, нужно использовать метод json():
response()→json()

public function test2(News $news)
{
	return response()→json($news→getNews()); - без указания заголовков
}

Метод контролера (как вариант) должен вернуть полученные данные.

    public function test2(News $news){							//инъекция зависимости от класса News
        return response()->json($news->getNews())					//используем метод getNews() класса News для получения всех новостей и преобразуем ответ в формат JSON
            ->header('Content-Disposition', 'attachment; filename = "news.txt"')	//указываем, что ответ нужно сохранить в виде файла
            ->setEncodingOptions(JSON_UNESCAPED_UNICODE | JSON_PRETTY_PRINT);		//преобразуем символы UNICODE (\u041D)  в кириллицу
    }

За пределами Laravel преобразовать кириллицу в UNICODE можно, например, так:
json_encode($str, JSON_UNESCAPED_UNICODE);

В /config/filesystems.php содержатся настройки, которые позволяют Laravel работать с файлами.
По умолчанию Laravel хранит скомпилилованные файлы приложения в папке /storage/app,
при этом данные, хранящиеся в папке /storage/app/public могут быть доступны извне сервера.

Для работы с файлами в контроллер необходимо подключить фасад Storage, который имеет
метод Storage::disk('название одного из дисков, указанных в файле /config/filesystems.php').
К данным, возвращаемым методом disk() можно применять методы
Storage::disk('disk_name')->get('filename.ext');	//чтение из файла
и
Storage::disk('disk_name')->put('filename.ext');	//запись в файл

В ДЗ потребуется news.json:
Storage::disk('local')->put('news.json', json_encode($news->getNews(), JSON_UNESCAPED_UNICODE | JSON_PRETTY_PRINT));
В результате будет создан файл в каталоге /storage/public.

В методе News::getNews() можно использовать
//json_decode('file_name', true); - по умолчанию возвращает объект, с опцией true возвращает массив

Для скачивания данных в формате xls или pdf можно использовать библиотеку Laravel excel

При работе в Laravel не следует использовать функции PHP file_get_contens() и file_put_contents(), т.к. это менее безопасно.

Пояснение ДЗ в видео - 1:29:30, 1:40:42, 1:47:30
ДЗ - создать страницу с формой "Скачать".
ДЗ - найти, как создать JSON-файл с помощью команды artisan

Настройка тестирования в Docker: 1:30:20
Для тестирования Laravel Sail в PHPStorm нажатием стрелки нужно установить и активировать плагины PHP и PHPDocker.
После этого в настройках PHP IDE нужно добавить новый CLI интерпретатор предварительно запустив контейнер Sail (при этом
 нужно в настройках сервера нажать кнопку "New").

Самый простой способ запустить тесты - использовать команду:

$php artisan test или $sail artisan test

Тестирование в Laravel:
https://www.youtube.com/watch?v=nef9Rozfp_U


Урок 5. Работа с базой данных. Запросы. Миграции

Метод для сохранения данных в файл:
public function save(News $news)
{
    \Illuminate\Support\Facades\Storage::disk('local')->put(
        'news.json',
        json_encode($news->getNews(),
        JSON_BIGINT_AS_STRING | JSON_PRETTY_PRINT));
}

Для создания пользовательской сервисной команды для artisan служит команда make:command,
которая создаёт файл ~app/Console/Commands/savejson.php:

sail artisan make:command savejson      //savejson - название команды
 INFO  Console command [app/Console/Commands/savejson.php] created successfully.

Файл ~app/Console/Commands/savejson.php содержит класс, расширяющий App\Console\Commands.
В нём нужно описать сигнатуру команды (protected $signature = 'save:json';),
а также переопределить метод обработчик handle();

При этом новая команда использует консольную точку входа в приложение.




php artisan help make:migration - вывести список доступных команд

Создадим новую таблицу для сохранения новостей. Для этого введем команду:
sail artisan make:migration create_news_table --create=news

Создался новый файл в директории ~/database/migrations. Открыв этот файл, увидим два метода:
up, который будет вызываться во время наката (выполнения) миграций, и down, который будет
выполняться, если придется откатить миграцию.
Cоздание файла миграций не означает его выполнение.

Фасад Schema — обертка для класса \Illuminate\Database\Schema\Builder.
create — статический метод фасада Schema,
первый параметр - название таблицы,
второй параметр - коллбек,
который в качестве параметра принимает объект класса Illuminate\Database\Schema\Blueprint
Благодаря методам класса Blueprint мы и создаем нужную структуру таблицы внутри самой функции.
У этого класса много методов, подробнее о них: https://laravel.com/docs/5.8/migrations#column
Разберем некоторые из них:
● bigIncrements — создает столбец первичного ключа с автоинкрементом. Принимает в
качестве параметра строку, которая и служит названием столбца;
● timestamps — добавляет в таблицу два столбца: created_at и updated_at;
● string — добавляет в таблицу столбец с типом данных VARCHAR. Первым параметром
принимает строку, которая будет именем столбца. Второй параметр необязательный — длина
строки;
● text — добавляет в таблицу столбец с типом данных TEXT. Первым параметром принимает
строку, которая будет именем столбца;
● json — добавляет в таблицу столбец с типом данных JSON. Первым параметром принимает
строку, которая будет именем столбца;
● bigInteger — добавляет в таблицу столбец с типом данных BIGINT. Первым параметром
принимает строку, которая будет именем столбца;
● dateTime — добавляет в таблицу столбец с типом данных DATETIME. Первым параметром
принимает строку, которая будет именем столбца;
● boolean — добавляет в таблицу столбец с типом данных BOOLEAN. Первым параметром
принимает строку, которая будет именем столбца.

Помимо основных методов, которые определяют тип данных столбца в таблице,
есть модификаторы колонок, которые позволяют установить дополнительные параметры столбца:
● default — метод указывает на то значение, которое будет установлено для колонки по
умолчанию;
● nullable — метод принимает true || false в качестве параметра и указывает, может ли быть
значение в данной колонке null.
● comment — принимает в качестве параметра строку, которая станет комментарием для
указанного столбца.
Данные модификаторы вызываются после определения типа столбца.

sail artisan migrate            //выполнить все миграций, которые есть в папке migrations
                                //(уже выполненные миграции повторно выполняться не будут)

sail artisan migrate:rollback   //отменить все миграции, которые были выполнены в данном предложении
                                //(таблица migrations сохранится).

sail artisan migrate:rollback --step=2      //откатить две последние миграции (указанные в таблице migrations)

В БД кроме таблиц, которые создаются при выполнении миграций, находящихся в папке migrations,
автоматически создаётся таблица migrations.
В таблице migrations хранится информация о тех миграциях, которые были выполнены.


Seeding — посев фейковых данных используется для тестирования приложения

sail artisan make:seeder NewsSeeder     //создать новый seeder
В папке ~database/seeds будет создан новый файл NewsSeeder.php
 — файл одноименного класса, в котором содержится единственный метод run,который будет выполняться при запуске seeder.

 Для заполнения базы данных фейковой информацией воспользуемся библиотекой fzaninotto/Faker.
 Предварительно установим ее через composer — команда для установки библиотеки:
 //устарело
 composer require fzaninotto/faker - библиотека не поддерживается.

 По умолчанию в Laravel входит https://packagist.org/packages/fakerphp/faker

Работа с seeder:
в методе run обращаемся к фасаду DB, который обратится к объекту класса \Illuminate\Database\Query\Builder.
Таким образом мы получим возможность добавлять данные в указанную таблицу.
У полученного объекта вызываем метод insert, который и будет производить данную вставку. Метод insert ожидает массив
данных, в котором ключи будут соответствовать полям таблицы.

Для генерации данных создаем отдельный метод getData и в нем обращаемся к библиотеке, которую
установили.
Обращаемся к статическому методу create и указываем локализацию.
После этого набираем массив из 10 подмассивов.

Каждый подмассив — отдельная строка в базе данных.

Для каждого подмассива собираем фейковые данные.
Для этого используем объект, сохраненный в переменной $faker, и вызываем соответствующие метод:
● sentence — метод класса Faker\Generator, возвращающий предложение, состоящее из указанного количества строк.
В данной библиотеке нет реализации данного метода на русском языке, поэтому результат на английском;
● realText — возвращает указанное количество слов из реального текста, минимум 10 и максимум 200.

Для запуска посева необходимо в консоли выполнить команду
 sail artisan db:seed --class=NewsSeeder
Seeders можно запускать любое количество раз.

Взаимодействие с базой данных
Для взаимодействия с базой данных воспользуемся фасадом DB и его методами.
select - позволяет использовать обычные SQL-запросы c возможностью экранировать данные, полученные от пользователя.
Статический метод Select принимает SQL-запрос, в результате которого получаем массив std-классов.
stdClass в PHP является предопределенным и часто используется для заполнения динамическими свойствами.
В метод select нельзя передавать данные, полученные от пользователя, без предварительной проверки (обработки),
т.к. они небезопасны.
Данные, полученные от пользователя могут содержать SQL-инъекцию (атака на базу данных).
Подробнее о  SQL-инъекциях можно прочитать в статье
https://habr.com/ru/post/148151/

Для защиты SQL-инъекций в Laravel используются подготовленные запросы.
Сначала базе говорится, какой запрос будет происходить, и указывается, куда в запросе нужно подставить данные.
Затем передаются данные и выполняется запрос.
Данные подставляются в строго отведенные им места, что исключает атаку.
Вторым параметром в Select передаем массив, ключом в котором указываем названия плейсхолдеров.
В значении передаем данные для подстановки.

DB::select(
    'SELECT id, title FROM news WHERE id = :id',
    ['id'=>$id]
);
В примере выше в SQL-запросе используется один плейсхолдер :id,
поэтому в массиве содержится одна пара «ключ —значение»: 'id'=> $id.

Помимо статичного метода для получения данных из базы, у фасада DB есть и другие:
● selectOne(string $query, array $bindings = []) — метод для поиска одной записи;
● select(string $query, array $bindings = []) — метод для выборки более чем одной записи;
● insert(string $query, array $bindings = []) — метод для вставки;
● update(string $query, array $bindings = []) — метод для изменения;
● delete(string $query, array $bindings = []) — метод для удаления;
● statement(string $query, array $bindings = []) — метод для запросов, не возвращающих результат.



Конструктор запросов

В практике работы с базой данных использование подхода, описанного выше, допустимо. Но он используется реже, чем
конструктор запросов.

У фасада DB существует метод table('название таблицы'),
возвращающий объект класса Illuminate\Database\Query\Builder.
Он содержит большое количество методов, которые используются для создания запросов к базе данных.
Пример:
$news = DB::table('news')->get();               //извлечь все строки из БД
$news = DB::table('news')->find($id);           //извлечь из БД строку с конкретным id

Примеры использования агрегатных функций count, max, min, avg и sum:
o DB::table('news')->count();
o DB::table('news')->max('id');

Примеры объединения таблиц:
$users = DB::table('users')
    ->join('contacts', 'users.id', '=', 'contacts.user_id')
    ->join('orders', 'users.id', '=', 'orders.user_id')
    ->select('users.*', 'contacts.phone', 'orders.price')
    ->get();

$users = DB::table('users')
    ->leftJoin('posts', 'users.id', '=', 'posts.user_id')
    ->get();

Примеры использования условий: where, orWhere, whereBetween, whereNotBetween, wherein, whereNotIn, whereNull,
whereNotNull, whereDate, whereMonth, whereDay, whereYear:
$users = DB::table('users')->where('votes', '=', 100)->get();

$users = DB::table('users')->where([
    ['status', '=', '1'],
    ['subscribed', '<>', '1'],
    ])->get();

$users = DB::table('users')
    ->where('votes', '>', 100)
    ->orWhere('name', 'John')
    ->get();

$users = DB::table('users')
   ->whereIn('id', [1, 2, 3])
   ->get();





 Конспект вебинара:

 В PHPStorm подключиться к контейнеру Docker можно с использованием вкладки Services,
 которая расположена рядом со вкладкой Terminal.

Значения переменных из контроллеров передаются в шаблоны с помощью сессий.
В контроллере при успешном действии создадим сессию с именем 'success' и выполним редирект на нужную странцу, а шаблон layout её получит и обработает (@if @else):

return redirect()->route('routeName')->with('success', 'message text');

Благодаря использованию сессии 'success' в layout сообщения можно будет выводить на любой странице,
которая использует его.

Чтобы добавить компонент Alert Bootstrap, всплывающий после добавления новости можно использовать "одноразовую" сессию с ключом 'success':
нужно добавить его в layout (в шаблоне страницы у меня не сработал) и
сделать условный рендеринг. Перед этим нужно передать из контроллера ->with('success', "Новость успешно добавлена!").

 @if(session('success'))
    <div>{{ session('success') }} </div>
 @endif



 В   ~/config/database.php хранятся настройки подключения к БД.
 sqlite используется для тестирования.

 Хэлпер env('key', default) берёт значения указанного свойства из файла .env

 При использовании Sail в .env настройки подключения к БД будут такими
 (подключение к БД, которая запущена внутри контейнера Docker):

 DB_CONNECTION=mysql
 DB_HOST=mysql              //? будет использовано дефолтное значение '127.0.0.1', указанное в ~/config/database.php
 DB_PORT=3306
 DB_DATABASE=example_app
 DB_USERNAME=sail
 DB_PASSWORD=password,

 а при работе локально c OpenServer:

 DB_CONNECTION=mysql
 DB_HOST=127.0.0.1
 DB_PORT=3306
 DB_DATABASE=laravel
 DB_USERNAME=root
 DB_PASSWORD=

 Подключиться к БД можно двумя способами: через фасад DB

 В дальнейшем методы для работы с БД должны располагаться в контроллере, а не в модели.
 Извлечение нужных данных будет реализовано средствами БД, а не PHP.

 Для упрощённого просмотра БД в контейнере Docker можно использовать HeidiSQL.
В настройках подключения к БД HeidiSQL требуется указать имя хоста/IP
(в .env указано DB_HOST=mysql).
Чтобы определить внешний IP-адрес контейнера Docker Sail в виртуальной среде Linux,
командная строка которой появляется после ввода команды wsl,
ввести команды:
$ sudo apt install net-tools
$ ifconfig
Эта команда выведет параметры сети внешнего eth0 и внутреннего lo соединений.
Нам требуется внешний ip-адрес контейнера.
У меня он 172.17.88.101.
Остальные данные для настройки подключения в HeidiSQL я взял в .env.

Чтобы реализовать возможность работы над одним проектом нескольких разработчиков с помощью Git,
используется механизм миграций.
Таблицы создаются с помощью PHP-команд.
Каждой таблице в БД соответствует отдельный PHP-файл.
Это позволяет всем разработчикам иметь актуальную версию БД после git pull.

Для создания миграций используются библиотеки.
В Laravel библиотека для создания миграций входит по умолчанию.
Laravel/Database/Getting started

Перед выполнением миграций нужно вручную создать пустую БД, например, при развёртывании проекта на хостинге. Имя БД должно совпадать с указанным в .env

Чтобы создать структуру БД нужно создать файлы миграций, а затем их выполнить.
По умолчанию в Laravel имеется несколько миграций: ~/database/migrations/,
в том числе, для создания таблицы users.

Файлы миграций (заготовки)  создаются с помощью команды
$ sail artisan make:migration name_migration

Команда создания модели автоматически с ключом -m автоматически создаёт и миграции для неё:
$ sail artisan make:model ModelName -m

Имя файла миграции должно содержать имя таблицы и описывать то, что с ней происходит:
create - создание таблицы
 //создание таблицы новости
$ sail artisan make:migration create_news_table

//добавление столбца category_id в таблицу news
$ sail artisan make:migration alter_table_news_add_column_category_id

Для добавления связей между таблицами (внешних ключей) нужно, чтобы типы данных связываемых столбцов были одинаковыми.

Пример миграции для изменения типа данных столбца (->change()) с установкой дефолтного значения (default()):
$table->unsignedBigInteger('category_id')->default(1)->change();

Laravel 8
Метод foreignId создает эквивалент столбца UNSIGNED BIGINT, в то время как метод constrained будет использовать соглашения для определения имени таблицы и столбца, на которые ссылаются. Если имя вашей таблицы не соответствует соглашениям Laravel, вы можете указать имя таблицы, передав его в качестве аргумента методу constrained:

Schema::table('posts', function (Blueprint $table) {
    $table->foreignId('user_id')->constrained('users');
});


Для автоматического каскадного удаления всех строк БД при удалении строки, на которую ссылается их внешний первичный
ключ, используется метод ->restrictOnDelete().
Также существует ->restrictOnUpdate().

Создание внешнего ключа таблицы
$table->foreign('foreign_key')->references('column_name')->on('table_name');    ->restrictOnDelete() для каскадного
удаления данных

Миграции создают связи между данными на уровне БД, но модели об этом пока ничего не знают.
Нужно организовать связи между данными на уровне моделей, что позволит использовать все преимущества ORM.
Чтобы, например, из новости получать её категорию,
или по id категории получить все новости этой категории.
В Laravel связи между моделями называются отношениями.
Средствами Laravel могут быть реализованы связи:
 один ко многим     - $this->belongsTo(Category::class, 'id' )->first();
 многие ко многим   - $this->hasMany(class, property_name)

 Например, в модель Category нужно добавить метод, возвращающий все новости этой категории
   //название метода соответствует классу, с которым создаётся связь
     public function news()
     {
        //->has_Many() свяжет внешний ключ (category_id) указанного класса (News) с первичным ключом класса (Category),   в котором   создаётся    метод.
         return $this->hasMany(News::class, 'category_id');
     }
 Тогда, чтобы получить массив связанных новостей,
 из родительского класса Category можно обратиться к свойству:
     $category->news,
 или использовать метод:
     $category->news()->get()


А в модель News добавить метод, возвращающий категорию соответствующей новости:
  //название метода соответствует классу, с которым создаётся связь
    public function category()
    {
        //->belongsTo() свяжет внешний ключ category_id класса, в котором создаётся метод (News), с первичным ключом     класса,     указанного в    первом параметре (Category)
        return $this->belongsTo(Category::class, 'category_id' )->first();
    }

Для выполнения миграций (внесения изменений в структуру БД) нужно выполнить команду:
$ sail artisan migrate

Для "отката" изменений, внесённых в БД последней миграцией
(командой $ sail artisan migrate)
используется команда:
$sail artisan migrate:rollback

Для добавления столбца category_id  в таблицу news необходимо создать миграцию командой:
sail artisan make:migration add_category_id_column_to_news_table --table=news

Для заполнения таблиц фейковыми данными используется "посев" Seeding
Seeders располагаются в ~/database/seeders/

Фабрики сидеров находятся в ~/database/factories/ - с помощью них удобно производить "посев". Пока обойдёмся без них.

Для создания файла для заполнения БД данными используется команда:
$ sail artisan make:seeder TableNameSeeder      //на первом месте - название таблицы + Seeder

В ~/database/seeders/DatabaseSeeder.php и во всех сидерах имеется метод run((), который выполняет "посев".

Библиотека Faker предустановлена в Laravel по-умолчанию (composer.json).
Документацию по Faker можно найти на сайте  https://packagist.org/.
Внутри сидера новостей создадим метод getData(), который будет возвращать случайные данные (с помощью Faker),
которыми будет заполняться таблица БД.

Если требуется подключить Faker в проект, лучше всего это делать в
~/app/Providers/AppServiceProvider.php в
    public function boot()
    {
    //подключает пагинатор Bootstrap
        Paginator::useBootstrap();

        //не тестировал
        //создаёт локализованный для русского языка экземпляр класса Faker.
        Faker\Factory::create('ru_Ru');
    }
    После этого один экземпляр русифицированного Faker будет доступен во всех классах приложения, а не создаваться в
    каждом классе заново.

Если Seeder или другой класс не подключается автоматически (не попадает в автозагрузчик),
возникает ошибка "Класс не найден",
то нужно выполнить команду:

composer dump-autoload

Пример Seeder:
<?php
namespace Database\Seeders;

use Illuminate\Database\Seeder;
use Faker;
use Illuminate\Support\Facades\DB;

class NewsSeeder extends Seeder
{
    /**
     * Run the database seeds.
     *
     * @return void
     */
    public function run()
    {
        DB::table('news')->insert($this->getData());
    }

    public function getData()
    {
        $data = [];
        //создаёт локализованный для русского языка экземпляр класса Faker.
        $faker = Faker\Factory::create('ru_Ru');
        //для создания массива новостей используем цикл
        for ($i = 0; $i < 5; $i++) {
            $data[] = [
                'title' => $faker->realText(rand(10, 30)),
                'text' => $faker->realText(rand(1000, 3000)),
                'isPrivate' => $faker->boolean()
            ];
        }
        return $data;
    }
}

  $faker = Faker\Factory::create('ru_Ru');      //создаёт локализованный для русского языка экземпляр класса Faker.

  Если обращаться к БД напрямую (не использую фасад DB), то будет утеряно кэширование и безопасность и т.п.,
  предоставляемые  фреймворком.

      /*  DB::table('tableName')->insert(массив или массив массивов);
        Если передать один массив - то в таблицу будет добавлена одна строка и метод вернёт её id,
        если передать массив массивов, то будет добавлено число строк, равное количеству элементов внешнего массива.*/
        DB::table('news')->insert($this->getData());

Для запуска сидера используется команда:
$ sail artisan db::seed --class=ClassNameSeeder,
где ClassNameSeeder - название класса сидера.

Если в БД много таблиц, то выполнять посев данных в каждую из них отдельной командой затратно, поэтому используется
класс DatabaseSeeder, который присутствует в Laravel по умолчанию и содержит метод run().
Последовательность запуска сидеров внутри run() имеет значение:
сначала нужно засеивать таблицы, столбцы в которых не ссылаются на другие таблицы
(т.к. сначала таблица категорий, а потом таблица новостей, которые относятся к категориям),
чтобы избежать ошибок.

        //вызов нужного seeder
        $this->call(NewsSeeder::class);

//Очистить БД, перезапустить миграции, засеять БД данными
$ sail artisan migrate:fresh --seed

Чтобы извлечь данные из БД нужно использовать фасад DB.
Например:
$news = DB::select('SELECT * FROM `news` WHERE 1');     //возвращает объект
Использовать метод select можно только в исключительных случаях,
когда невозможно обойтись средствами конструктора запросов.

Методы фасада DB (например get()) возвращают коллекции,
т.е. массивы, элементы которых являются объектами, содержащими данные и методы
для работы с ними.
Чтобы преобразовать их в массив, можно использовать метод ->get()->toArray(),
но делать это не рекомендуется, т.к. теряется гибкость,
кроме того, лишние действия снижают производительность приложения.

get()       - возвращает все данные из таблицы,
find($id)   - возвращает строку таблицы с id = $id.

  StyleGuide:
  имена классов сущностей называть в единственном числе (каждый экземпляр модели содержит одну запись БД) с заглавной
  буквы,
  а таблицам, хранящим данные этих сущностей, во множественном с маленькой.

Механизм миграций реализует функционал системы контроля версий при работе с БД.
Миграции позволяют собирать БД вне зависимости от исходного состояния,
т.к. при запуске миграции будут выполняться только те, которые ещё не выполнялись (новые).

sail artisan migrate:fresh      //удалить все таблицы из БД и запустить все миграции

 В ~/database/migrations/ хранятся файлы миграций.
 В каждой миграции есть методы:
  up() - для внесения изменений в БД
  down() - для отката изменений.

  метод ->id() создаёт первичный ключ (автоинкремент, всё что нужно),
  ранее вместо него использовался метод ->bigIncrements('id').
  ->default(value) - дефолтное значение
  ->comment(string)- комментарий к названию столбца
  ->string(string) - короткая строка
  ->text(string) - длинный текст
  Методы для создания полей подробно описаны в документации на сайте в разделе Migrations.
  00:40 - пример создания миграции (применение методов для создания полей нужных типов).


1. Продумать структуру сохранения данных следующих таблиц:
a. Новости.
b. Категории новостей по образцу.
c. Источники получения новостных данных.
Структура может быть реализована в виде рисунка, таблиц или специальных диаграмм.

2. Сделать миграции для таблиц из первого задания. Миграции должны иметь роллбеки.
sail artisan make:migration create_categories_table
sail artisan make:seeder CategoriesSeeder


3. С помощью сидинга реализовать заполнение созданных таблиц фейковыми данными.
Таблица категорий — минимум 5 записей. Таблица новостей — минимум 10 записей на
каждую категорию. Таблица источников — минимум 10 записей.

4. Удалить созданные методы в контроллере для хранения данных и реализовать вывод данных
из базы.

Связи между таблицами делать не нужно.
Подумать как извлечь новости конкретной категории.

Нужно переделать метод create() в Adminj\NewsController.php.
Вместо Storage::disk() - insert(),
если идёт редирект на эту новость, то insertGetId() - возвращает id добавленной записи.
Подробнее о ДЗ 1:31, 1:33
Продолжить просмотр с 1:39 (добавление картинки в HTML)

Чтобы файлы, находящиеся в папке ~/storage стали доступны в браузере,
нужно создать символическую ссылку (ярлык) командой:
$ sail artisan storage:link
   INFO  The [public/storage] link has been connected to [storage/app/public].

Конспект лекции №6: Работа с базой данных. Eloquent ORM. Laravel Debugbar

Laravel Debugbar - внешний компонент. Его аналог присутствует в Laravel UI.
Помогает получать большое количество отладочной информации (например, Request) прямо в окне браузера без использования dump().

Искать на packagist.org (barryvdh/laravel-debugbar)
sail composer require barryvdh/laravel-debugbar --dev

ORM (англ. Object-Relational Mapping, рус. объектно-реляционное отображение, или преобразование) — технология программирования, которая связывает базы данных с концепциями объектно-ориентированных языков программирования, создавая «виртуальную объектную базу данных».

DB:: - надстройка над библиотекой PDO

Создать модель extends Model:
sail artisan make:model ModelName

Более правильный способ создания модели - использование параметра -m, который автоматически создаёт миграцию для
создаваемой модели:

$ sail artisan make:model Category -m
   INFO  Model [app/Models/Category.php] created successfully.
   INFO  Created migration [2022_11_21_113456_create_categories_table]


use HasFactory внутри тела класса означает использование трейта HasFactory.

Класс Model имеет большое количество полей, например:
    protected $table;               название таблицы
    protected $primaryKey = 'id';   первичный ключ
в классе наследнике их можно переопределять.

Создание класса модели (даже созданного по умолчанию - без редактирования)
позволяет использовать ORM, т.к. на самом деле он не пуст, потому что встроенный в Laravel класс Model, от которого наследуются пользовательские модели, имеет большое количество полей и методов для работы с ними:
для получения данных из БД вместо фасада DB использовать фасад,
соответствующий названию класса модели.
Например:
$news = DB::table('news')->get();
идентично
$news = News::all();    //возвращает коллекцию - массив объектов класса-модели
Каждый объект коллекции содержит не только данные, но и методы для работы с ними.

$news = DB::table('news')->find($id);
идентично
$news = News::query()->find($id);
метод query() берёт имя таблицы из самой модели News.

ORM упрощает использование маршрутов с параметрами.
Если имя параметра в маршруте совпадает с именем модели (/{news}), и в методе контроллера в качестве параметра
используется
название модели (News $news), то в контроллере будет создан (вернее, получен из контейнера) не пустой объект News, а
соответствующий переданному в маршруте параметру.
Т.е. из БД будет возвращаться строка со значением первичного ключа, равным переданному в адресной строке браузера, либо
произойдёт перенаправление на страницу '404'.
Кроме того, в представлениях в динамических маршрутах, в которых используются экземпляры класса-модели, не требуется
указывать первичный ключ таблицы, т.к. Laravel извлечёт его и подставит в маршрут по-умолчанию.
Например:
href="{{ route('news.show', $item->id) }}"
идентично
href="{{ route('news.show', $item) }}",
т.е. разработчику не требуется помнить название первичного ключа модели.

Принцип работы фасада - при необходимости будет создан экземпляр класса и помещён в контейнер.
При повторном обращении к классу новый экземпляр создаваться не будет, а будет браться из контейнера.

Пример запроса с использованием ORM (AR):
выводит неприватные новости:
$news = News::query()->where('isPrivate', false)->get();
сработает даже так:
$news = News::where('isPrivate', false)->get();


Пагинация.

$news = News::query()->paginate($n); - возвращает не коллекцию, а объект paginator, одним из свойств которого является
коллекция объектов нужного класса. Кроме того, имеются методы для работы с данными объекта:
{{ $news->links() }} - по умолчанию в шаблоне для пагинации будут использованы стили TailWind, но их можно изменить на
пользовательские.
Для применения пользовательских стилей к пагинации можно в ~/app/Providers/AppServiceProvider.php зарегистрировать новые
компоненты функционала в методе register(), а в методе boot() указать инициализации, которые будут происходить при
загрузке.
Paginator::useBootstrap(); //применить стили Bootstrap к пагинации при загрузке


Работа с коллекциями

Хэлпер collect([]) возвращает объект класса-коллекции Illuminate\Support\Collection, который имеет очень много методов
для работы с данными, которых не имеют обычные массивы, например, найти дубли, объединять, count, min, max, last, first,
 sort и т.п..
 Например:
 ->keyBy('id'); // позволяет привести первичные ключи коллекции (аналог номеров элементов в массиве) в соответствие
 указанному в качестве параметра ключу объектов, входящих в
 коллекцию.
 ->diff();      //найти отличия

$collection = collect([1,2,3]);

Если не использовать библиотеку Laravel/UI, то пользовательские стили (в том числе и Bootstrap) и  скрипты нужно
подключать в теге
head:
<script src="{{ asset('js/app.js' }}" defer></script>
<link href="{{ asset('css/app.js' }}" rel="stylesheet"></script>

Вместо ->get()[0] пишите first()

Плюсом использования ORM является дополнительная защита от изменения данных, т.к. модель этого не даст.
Чтобы получить возможность изменять данные в модели, нужно внутри неё создать protected свойство $fillable = []. В
массиве свойства $fillable нужно указать свойства модели, которые будет разрешено изменять.
Тогда этот блок команд сохранит в модель только те данные из класса Request, которые перечислены в свойстве fillable:
       $data = $request->all();     //получение всех данных объекта класса Request
       $news->fill($data);          //заполнение только тех полей экземпляра класса News, которые перечислены в его
       свойстве fillable
       $news->save();               //Сохранение строки в БД

После этого, согласно паттерну Active Record,
$id = $news->id; //метод ->save() заполнит значение id полученным из БД номером строки?

->save() понимает, с новой или старой записью мы работаем, поэтому операции CRUD Create и Update в Laravel выглядят
практически одинаково.

При выполнении операции CRUD Delete, метод delete() возьмёт id из свойства объекта, с которым совершается операция:
$news->delete()

StyleGuide
Название метода контроллера, название маршрута, название представления (view) должны совпадать.

Для разграничения действий с ресурсами на уровне HTTP-методов и были придуманы следующие варианты:
GET — получение ресурса
POST — создание ресурса
PUT — обновление ресурса
DELETE — удаление ресурса

Чтобы реализовать отправку запроса методом DELETE в HTML кнопку нужно обернуть в тег form,
создать скрытое поле (hidden), в котором указать HTTP-метод.

Для редактирования новости повторно используем форму добавления новости.
Для назначения правильного маршрута обработчика в теге форм будем использовать тернарный оператор, который проверяет
наличие свойства id в объекте $news (если мы создаём новость, то объект будет пуст):

 <!-- Если $news содержит поле id, значит мы не создаём новость, а редактируем-->
<form id="news__add"
action="{{ $news->id ? route('admin.update', $news): route('admin.create') }}"
method="post">

Тернарный оператор удобно использовать и в заголовках формы:
 <div>
{{$news->id ? 'Редактировать' : 'Добавить'}} новость
</div>

Также для реализации редактирования новости в одной форме с созданием,
в тегах input нужно использовать оператор сравнения с null ??:
  <input name="title" value="{{ $news->title ?? old('title') }}">
  если заголовок новости пуст, то, при наличии, будет выведено старое значение.

Чтобы изменить метод отправки данных формой с POST на, например, DELETE, нужно внутри формы добавить директиву @method()
<form method="post">
 @csrf
 @method('DELETE')
</form>


Контроллеры ресурсов
https://laravel.com/docs/9.x/controllers#resource-controllers\

Также доступны

Частичные маршруты ресурсов
Вложенные ресурсы
Именование ресурсных маршрутов
Именование параметров маршрута ресурса
Обзор маршрутов ресурсов
Локализация URI ресурсов
Дополнение контроллеров ресурсов

Создание ResourceController (контроллера ресурсов)
sail artisan make:controller NameController -r
тогда все маршруты CRUD можно будет заменить одной строкой:
Route::resource('modelname', 'ModelController');

Маршрутизация ресурсов Laravel назначает типичные маршруты
«CRUD» контроллеру с помощью одной строки кода. Например, вы можете создать контроллер, который будет обрабатывать все HTTP-запросы для «фотографий», хранящихся в вашем приложении. С помощью команды make:controllerArtisan мы можем быстро создать такой контроллер:

php artisan make:controller PhotoController --resource

Эта команда сгенерирует контроллер в app/Http/Controllers/PhotoController.php. Контроллер будет содержать метод для каждой из доступных операций с ресурсами.
Далее вы можете зарегистрировать ресурсный маршрут к контроллеру:

Route::resource('photos', 'PhotoController');

Verb	URI 	                Action	Route Name
GET	    /photos	                index	photos.index
GET	    /photos/create	        create	photos.create
POST	/photos	                store	photos.store
GET	    /photos/{photo}	        show	photos.show
GET	    /photos/{photo}/edit    edit	photos.edit
PUT     /PATCH/photos/{photo}	update	photos.update
DELETE	/photos/{photo}	        destroy	photos.destroy





Урок 7. Валидация
данных в Laravel
Возможность Laravel валидировать данные, полученные из
запроса пользователя.

Валидация — это проверка данных на соответствие заданным условиям и ограничением.

Способы валидации:
https://laravel.demiart.ru/ways-of-laravel-validation/

В Laravel есть несколько подходов для проверки данных. Базовый вариант — валидация данных в контроллере при помощи набора правил.
Базовый контроллер содержит трейт ValidatesRequests, в котором есть метод validate.
Этот вариант реализуется в контроллерах, которые в качестве параметра принимают Request.
Валидацию необходимо выполнять в момент получения данных из формы:
        $this->validate($request, className::rules()),
        где rules() - это метод, возвращающий массив правил (его нужно создать в модели).
        Набор правил можно сразу передать вторым параметром в метод
        $this->validate($request, [rules]); - это более распространённый и наглядный способ.
        Кроме того можно передать необязательные параметры:
        массив сообщений и массив пользовательских атрибутов.

  Доступные правила валидации:
  https://laravel.com/docs/9.x/validation#available-validation-rules-

В результате работы метода validate() в шаблоне становится доступной переменная $errors.
  Значение переменной  $errors, которая ссылается нао объект, который заполняется результатами работы метода validate() можно вывести в шаблон,
  но  только между секциями
     @dump($errors)

     Получить доступ к массиву ошибок в объекте $errors можно с помощью методов:
$errors->has('text'): boolean - проверяет наличие в массиве ошибок, связанных с элементом формы, имещюм name="text";
$errors->get('text') :[string] - возвращает массив строк с описанием ошибок тега с указанным name="text"
$errors->all():[string] - возвращает плоский массив строк ошибок, содержащий ошибки всех тегов, независимо от имени

Если перебрать массив ошибок в шаблоне, то текст ошибки можно получить так:
@if($errors->has('text'))
    @foreach($errors->get('text') as $error)
        <label for="news__title"                                                          class="{{ $error ? 'text-danger':''}}">
         {{ $error }}
         </label>
    @endforeach
@endif

В Blade есть директива, которая позволяет вывести одну ошибку в шаблон:
@error('tag_name')
{{$message}}
@enderror

В Laravel имеется класс ~/vendor/laravel/framework/src/Foundation/Validation/ValidatesRequests.php, в котором есть метод
 public validate():

    * Validate the given request with the given rules.
      *
      * @param  \Illuminate\Http\Request  $request
      * @param  array  $rules
      * @param  array  $messages
      * @param  array  $customAttributes
      * @return array
      *
      * @throws \Illuminate\Validation\ValidationException
      */
     public function validate(Request $request, array $rules,
                              array $messages = [], array $customAttributes = [])
     {
         $rules = $request->isPrecognitive()
             ? $request->filterPrecognitiveRules($rules)
             : $rules;

         $validator = $this->getValidationFactory()->make(
             $request->all(), $rules, $messages, $customAttributes
         );

         return tap($validator, function ($validator) use ($request) {
             if ($request->isPrecognitive()) {
                 $validator->after(Precognition::afterValidationHook($request));
             }
         })->validate();
     }


Чтобы сохранить контроллер "тонким" валидацию можно выполнять в отдельном классе:
sail artisan make:request StoreNewsRequest
Request [app/Http/Requests/StoreNewsRequest.php] created successfully.

Тогда массив rules нужно перенести из контроллера в public function rules() созданного класса, а в самом контроллере
можно использовать
$validated = $request->validated(); возвращающий данные, прошедшие проверку.
//получить часть данных
 $validated = $request->safe()->only(['name', 'email']);
 $validated = $request->safe()->except(['name', 'email']);

Если проверка не пройдена, будет сгенерирован ответ перенаправления, чтобы отправить пользователя обратно в его предыдущее местоположение.
Ошибки также будут переданы в сеанс, чтобы они были доступны для отображения.
Если запрос был запросом XHR, пользователю будет возвращен ответ HTTP с кодом состояния 422, включая JSON-представление ошибок проверки.

В public function rules() нужно обрабатывать запросы всеми HTTP-методами, используя switch ($this->method()){ case }.
public function rules()
    {
    switch ($this->method()) {
        case 'GET':
        case 'DELETE': {
            return [
              'id'=>'required|exists:posts,id'
            ];
        }
        case 'POST': {
            return [
            'title'=> 'required|min:10',
            'description' => 'required'
            ];
        }
        case 'PUT':
        case 'PATCH': {
            return [
              'id'=>'required|exists:posts,id'
            'title'=> 'required|min:10',
            'description' => 'required'
            ];
        }
        default:
            break;
    }
    }


Локализация Laravel

В папке ~/lang/ находятся папки с языковыми пакетами (локалями).
В них в том чиле хранится файл с текстами ошибок валидации: validation.php

Также зыковые пакеты можно устанавливать выборочно, вручную скопировав нужный файл:
php-файлы языковых пакетов должны храниться в подпапках ~/lang/,
JSON-файл языковых пакетов должны располагаться непосредственно в каталоге  ~/lang/.

Язык по умолчанию для приложения хранится в параметре config/app.php конфигурации файла locale конфигурации

Язык по-умолчанию можно переключить для одного запроса методом
App::setLocale($locale);

Языковые пакеты можно установить с помощью Composer (огромное количество языков).
Например, Laravel Lang (92? языка).
Вручную установить языковой пакет из Laravel Lang не получится.
Для установки одного языка из Laravel Lang требуется предварительно установить Laravel Lang Publisher:
sail composer require laravel-lang/publisher laravel-lang/lang laravel-lang/attributes --dev
Скопировать папки с нужными пакетами из GitHub в ~/lang/
Выполнить команду:
sail artisan vendor:publish --provider="LaravelLang\Publisher\ServiceProvider"
Для установки нужного пакета выполнить команду:
sail artisan lang:add ru
При этом будет создан файл ru.json
Доступтные команды Laravel Lang Publisher:
  ⇂ lang:add
  ⇂ lang:reset
  ⇂ lang:rm
  ⇂ lang:update
  ⇂ migrate:install
  ⇂ sail:install
  --force нужно добавлять для удаления защищённого пакета

Получить строку перевода из файла языкового пакета php:
{{ __('messages.welcome') }}, где messages - имя файла, а welcome - ключ массива

Получить строку перевода из файла языкового пакета json
(используются строки перевода по умолчанию в качестве ключей перевода):
{{ __('I love programming') }}, где I love programming - строка в файле json.

Сбросить кэш Laravel:
sail artisan cache:clear


Тестирование форм. Тестирование автоматического поведения.
Laravel Dusk предоставляет выразительный и простой в использовании API для автоматизации и тестирования браузера. По умолчанию Dusk не требует установки JDK или Selenium на локальный компьютер. Вместо этого Dusk использует автономную установку ChromeDriver .
!!! Вы никогда не должны регистрировать его в своей производственной среде, так как это может привести к тому, что
произвольные пользователи смогут пройти аутентификацию в вашем приложении!!!
sail composer require --dev laravel/dusk
sail artisan dusk:install
ChromeDriver binary successfully installed for version 107.0.5304.62.

Затем установите APP_URLпеременную среды в .envфайле вашего приложения. Это значение должно соответствовать URL-адресу, который вы используете для доступа к своему приложению в браузере.

Запуск тестов
Laravel предоставляет потрясающую поддержку тестирования «из коробки», и вы можете использовать testкоманду Sail для запуска функциональных и модульных тестов приложений.
Любые параметры CLI, которые принимает PHPUnit, также могут быть переданы в test команду:
sail test
эквивалентно
sail artisan test

Благодаря Sail вы можете запускать эти тесты, даже не устанавливая Selenium или другие инструменты на свой локальный
компьютер. Для начала раскомментируйте сервис selenium в docker-compose.yml файле вашего приложения:

selenium:
    image: 'selenium/standalone-chrome'
    volumes:
        - '/dev/shm:/dev/shm'
    networks:
        - sail

Затем убедитесь, что laravel.test служба в docker-compose.ymlфайле вашего приложения имеет depends_on запись для selenium:

depends_on:
    - mysql
    - redis
    - selenium

Наконец, вы можете запустить набор тестов Dusk, запустив Sail и выполнив dusk команду:
sail dusk

При возникновении ошибки:
1 / 1 (100%)file_put_contents(/var/www/html/.phpunit.result.cache): Failed to open stream: Permission denied
самый простой способ решить проблему - удалить файл .phpunit.result.cache из корневой папки проекта.

По умолчанию Sail создаст выделенную testingбазу данных, чтобы ваши тесты не мешали текущему состоянию вашей базы данных. При установке Laravel по умолчанию Sail также настроит ваш phpunit.xmlфайл для использования этой базы данных при выполнении ваших тестов:

<env name="DB_DATABASE" value="testing"/>

Тесты можно создавать по образцу: ~/tests/Browser/ExampleTest.php
Если тест не будет пройден, то в папке ~/tests/Browser/screenshots появится скриншот.

Создать новый тест браузера Dusk:
sail artisan dusk:make AdminNewsTest

Имена методов тестов должны описывать их назначение.

При выполнении тестов возможна ситуация, при которой валидация будет успешно пройдена и тестовые данные будут заненсены
в БД. Чтобы не засорять Production-БД для тестов используют другую БД.


Чтобы запустить проект Laravel Sail локально, достаточно скопировать папку проекта в каталог OpenServer и сделать
соответствующие настройки окружения в OpenServer:
версии PHP, имя домена?

Чтобы реинициализировать БД при каждом запуске теста в класс теста нужно добавить трейт
use RefreshDatabase
(см. методичку).
Это приведёт к тому, что запись, добавленная в БД после запуска теста, при следующем запуске теста будет удаляться.

Более правильный вариант работы тестов с БД -
чтобы не писать тестовую информацию в рабочую БД, нужно создать файл .env.dusk и в нём описать подключение к тестовой БД.
Если в папке проекта имеется файл .env.dusk, то настройки, указанные в нём будут использоваться при запуске тестов.

Практическое задание
1. Добавить валидирование данных, которые получены из форм, созданных на предыдущих
уроках.
2. Используя знания, полученные на уроке, реализуйте вывод сообщений об ошибках валидации полей форм (из задания 1).
3. Добавьте тесты — минимум по две проверки на каждую форму

В итоговом варианте для учётной записи админа сделать
логин admin@admin.ru
пароль 123
и заполнить ими атрибуты value соответствующих инпутов.

Завалидировать все формы, кроме формы логина.
Осталось сделать валидацию формы CRUD категорий, а также закончить валидацию остальных HTTP-методов формы новостей (без
дублирования - нужно делать валидацию в модели или отдельном классе).
.
Сделать проверку, чтобы не было возможности добавить в БД уже существующую категорию (по аналогии с полем id).
В форме ввода логина изменить правила, чтобы можно было использовать пароль из 3 символов.

Сделать по 1-2 теста на каждую форму:
вбить данные во все поля (->type() для каждого поля формы),
нажать на кнопку Добавить,
проверить, работает ли валидация,
видит ли браузер ошибки валидации (-assertSee()).

ToDo набить руку на создании CRUD-операций: роут - контроллер - модель - работа с БД и формой.
ToDo посмотреть англоязычные ролики по Laravel Inertia

Помощь преподавателя по установке Dusk

sail artisan dusk --do-not-cache-result
wget -q -O - https://dl-ssl.google.com/linux/linux_signing_key.pub | sudo apt-key add -
sudo sh -c 'echo "deb [arch=amd64] http://dl.google.com/linux/chrome/deb/ stable main" >> /etc/apt/sources.list.d/google-chrome.list'
sudo apt-get update && sudo apt-get install -y google-chrome-stable
sudo apt-get install -y xvfb
